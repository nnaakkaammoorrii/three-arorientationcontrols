/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js?!./src/style.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./src/style.css ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"body { margin: 0; }\\ncanvas { width: 100%; height: 100% }\", \"\"]);\n\n\n//# sourceURL=webpack:///./src/style.css?./node_modules/css-loader/dist/cjs.js??ref--5-1");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./node_modules/three-arorientationcontrols/AROrientationControls.js":
/*!***************************************************************************!*\
  !*** ./node_modules/three-arorientationcontrols/AROrientationControls.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var THREE = ( false) ? undefined : __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nTHREE.AROrientationControls = function(object, scene, domElement, options) {\n\n\tvar scope = this;\n\tscope.object = object;\n\tscope.object.rotation.reorder('YXZ');\n\n\tscope.deviceOrientation = {};\n\tscope.screenOrientation = 0;\n\tscope.alphaOffset = 0; // radians\n\n\tscope.scene = scene;\n\tscope.domElement = domElement;\n\n\tscope.init = false;\n\tscope.enabled = false;\n\n\tvar mode;\n\n\tvar canUseDeviceorientation = false;\n\tvar canUseCamera = false;\n\n\tvar videoStream\n\tvar bgVideo;\n\tvar bgTrackSettings;\n\tvar bgCanvas;\n\tvar bgContext;\n\n\tvar onDeviceOrientationChangeEventInit = function() {\n\t\tcanUseDeviceorientation = true;\n\t};\n\n\tvar getUserMedia = function(callback) {\n\t\tnavigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: \"environment\" } }).then(function(stream) {\n\t\t\t\tvideoStream = stream;\n\t\t\t\tbgVideo = document.createElement('video');\n\t\t\t\tbgVideo.autoplay = true;\n\t\t\t\tbgVideo.srcObject = stream;\n\t\t\t\tbgTrackSettings = stream.getVideoTracks()[0].getSettings();\n\n\t\t\t\tbgCanvas = document.createElement('canvas');\n\t\t\t\tbgCanvas.width = 256;\n\t\t\t\tbgCanvas.height = 256;\n\t\t\t\tbgContext = bgCanvas.getContext('2d');\n\n\t\t\t\tcanUseCamera = true;\n\n\t\t\t\tif (callback) callback();\n\t\t\t})\n\t\t\t.catch(function(err) {\n\t\t\t\tcanUseCamera = false;\n\t\t\t\tif (callback) callback();\n\t\t\t});\n\t};\n\n\tvar init = function() {\n\t\twindow.removeEventListener('deviceorientation', onDeviceOrientationChangeEventInit, false);\n\n\t\tif (options.mode === 'ar' && canUseDeviceorientation && canUseCamera) {\n\t\t\tmode = 'ar';\n\t\t}\n\t\telse {\n\t\t\tif ((options.mode === 'ar' && options.failSafe) || options.mode === 'vr') {\n\t\t\t\tmode = 'vr';\n\t\t\t\tif (videoStream) {\n\t\t\t\t\tvideoStream.getVideoTracks()[0].stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (options.error) options.error();\n\t\t\t}\n\t\t}\n\n\t\tscope.init = true;\n\t\tscope.connect();\n\t\tif (options.success) options.success(mode);\n\t};\n\n\tvar onDeviceOrientationChangeEvent = function(event) {\n\t\tscope.deviceOrientation = event;\n\t}\n\n\tvar onScreenOrientationChangeEvent = function() {\n\t\tscope.screenOrientation = window.orientation || 0;\n\t};\n\n\tvar setObjectQuaternion = function() {\n\t\tvar zee = new THREE.Vector3(0, 0, 1);\n\t\tvar euler = new THREE.Euler();\n\t\tvar q0 = new THREE.Quaternion();\n\t\tvar q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\t\treturn function(quaternion, alpha, beta, gamma, orient) {\n\t\t\teuler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us\n\t\t\tquaternion.setFromEuler(euler); // orient the device\n\t\t\tquaternion.multiply(q1); // camera looks out the back of the device, not the top\n\t\t\tquaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation\n\n\t\t};\n\t}();\n\n\tvar onMouseMoveEvent = function(event) {\n\t\tmouseX = -(event.clientX / scope.domElement.clientWidth) * 2 + 1;\n\t\tmouseY = -(event.clientY / scope.domElement.clientHeight) * 2 + 1;\n\n\t\tscope.object.rotation.x = mouseY;\n\t\tscope.object.rotation.y = mouseX;\n\t};\n\n\tvar rotateStart = null;\n\tvar dragStart = new THREE.Vector2();\n\tvar dragEnd = new THREE.Vector2();\n\tvar dragDelta = new THREE.Vector2();\n\n\tvar startRotate = function(clientX, clientY) {\n\t\tdragStart.set(clientX, clientY);\n\t\trotateStart = new THREE.Vector2(scope.object.rotation.x, scope.object.rotation.y);\n\t}\n\n\tvar doRotate = function(clientX, clientY) {\n\t\tif (rotateStart == null) return;\n\n\t\tdragEnd.set(clientX, clientY);\n\n\t\tdragDelta.subVectors(dragEnd, dragStart).multiplyScalar(0.5);\n\n\t\tscope.object.rotation.y = 2 * Math.PI * (dragDelta.x / scope.domElement.clientWidth) + rotateStart.y;\n\t\tscope.object.rotation.x = 2 * Math.PI * (dragDelta.y / scope.domElement.clientHeight) + rotateStart.x;\n\t}\n\n\tvar endRotate = function() {\n\t\trotateStart = null;\n\t}\n\t\n\tvar onMouseDown = function(event) {\n\t\tstartRotate(event.clientX, event.clientY);\n\t}\n\t\n\tvar onMouseMove = function(event) {\n\t\tdoRotate(event.clientX, event.clientY);\n\t}\n\t\n\tvar onMouseUp = function(event) {\n\t\tendRotate();\n\t}\n\t\n\tvar onTouchStart = function(event) {\n\t\tevent.preventDefault();\n\t\tstartRotate(event.touches[0].clientX, event.touches[0].clientY);\n\t}\n\t\n\tvar onTouchMove = function(event) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tdoRotate(event.touches[0].clientX, event.touches[0].clientY);\n\t}\n\t\n\tvar onTouchEnd = function(event) {\n\t\tendRotate();\n\t}\n\n\tvar connectAr = function() {\n\t\tonScreenOrientationChangeEvent(); // run once on load\n\t\twindow.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tif (videoStream == null) {\n\t\t\tgetUserMedia();\n\t\t}\n\t}\n\n\tvar connectVr = function() {\n\t\tdocument.addEventListener('mousedown', onMouseDown, false);\n\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\t\t\n\t\tdocument.addEventListener('touchstart', onTouchStart, {passive: false});\n\t\tdocument.addEventListener('touchmove', onTouchMove, {passive: false});\n\t\tdocument.addEventListener('touchend', onTouchEnd, {passive: false});\n\t}\n\n\tthis.connect = function() {\n\t\tif (scope.enabled || !scope.init) return;\n\n\t\tif (mode === 'ar') {\n\t\t\tconnectAr();\n\t\t}\n\t\telse if (mode === 'vr') {\n\t\t\tconnectVr();\n\t\t}\n\t\tscope.enabled = true;\n\t};\n\n\tvar disconnectAr = function() {\n\t\twindow.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tbgVideo.stop();\n\t\tvideoStream.getVideoTracks().forEach(function(devise) {\n\t\t\tdevise.stop();\n\t\t});\n\t\tvideoStream = null;\n\t}\n\n\tvar disconnectVr = function() {\n\t\tdocument.removeEventListener('mousemove', onMouseMoveEvent, false);\n\t}\n\n\tthis.disconnect = function() {\n\t\tif (mode === 'ar') {\n\t\t\tdisconnectAr();\n\t\t}\n\t\telse if (mode === 'vr') {\n\t\t\tdisconnectVr();\n\t\t}\n\t\tscope.enabled = false;\n\t};\n\n\tvar updateAr = function() {\n\t\tvar device = scope.deviceOrientation;\n\t\tif (!device) return;\n\n\t\tvar alpha = device.alpha ? THREE.Math.degToRad(device.alpha) + scope.alphaOffset : 0; // Z\n\t\tvar beta = device.beta ? THREE.Math.degToRad(device.beta) : 0; // X'\n\t\tvar gamma = device.gamma ? THREE.Math.degToRad(device.gamma) : 0; // Y''\n\t\tvar orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0; // O\n\t\tsetObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);\n\n\t\tif (bgVideo.readyState != bgVideo.HAVE_ENOUGH_DATA) return;\n\n\t\tbgContext.clearRect(0, 0, 256, 256);\n\t\tbgContext.drawImage(bgVideo, 0, 0, 256, 256);\n\n\t\tvar bgTeture = new THREE.Texture(bgCanvas);\n\t\tbgTeture.needsUpdate = true;\n\n\t\tlet canvasAspect = scope.domElement.clientWidth / scope.domElement.clientHeight;\n\t\tlet imageAspect = scope.domElement.clientWidth > scope.domElement.clientHeight ? bgTrackSettings.width / bgTrackSettings.height : bgTrackSettings.height / bgTrackSettings.width;\n\t\tlet aspect = imageAspect / canvasAspect;\n\n\t\tbgTeture.offset.x = aspect > 1 ? (1 - 1 / aspect) / 2 : 0;\n\t\tbgTeture.repeat.x = aspect > 1 ? 1 / aspect : 1;\n\n\t\tbgTeture.offset.y = aspect > 1 ? 0 : (1 - aspect) / 2;\n\t\tbgTeture.repeat.y = aspect > 1 ? 1 : aspect;\n\n\t\tif (scene.background) scene.background.dispose();\n\t\tscene.background = bgTeture;\n\t};\n\n\tvar updateVr = function() {\n\n\t};\n\n\tthis.update = function() {\n\t\tif (!scope.enabled) return;\n\n\t\tif (mode === 'ar') {\n\t\t\tupdateAr();\n\t\t}\n\t\telse if (mode === 'vr') {\n\t\t\tupdateVr();\n\t\t}\n\t};\n\n\tthis.changeMode = function() {};\n\n\tif (options.mode === 'ar') {\n\t\tif (window.DeviceMotionEvent) {\n\t\t\twindow.addEventListener('deviceorientation', onDeviceOrientationChangeEventInit, false);\n\n\t\t\tgetUserMedia(function() {\n\t\t\t\tsetTimeout(init, 1000);\n\t\t\t});\n\t\t}\n\t}\n\telse if (options.mode === 'vr') {\n\t\tinit();\n\t}\n\telse {\n\t\toptions.error('Invalid mode');\n\t}\n};\n\nif (true) {\n\tmodule.exports = exports.default = THREE.AROrientationControls;\n}\n\n//# sourceURL=webpack:///./node_modules/three-arorientationcontrols/AROrientationControls.js?");

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FaceNormalsHelper, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, JSONLoader, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, Light, LightProbe, LightProbeHelper, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NeverDepth, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PositionalAudioHelper, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RectAreaLightHelper, RedFormat, ReinhardToneMapping, RepeatWrapping, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StereoCamera, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VertexNormalsHelper, VideoTexture, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, sRGBEncoding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACESFilmicToneMapping\", function() { return ACESFilmicToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddEquation\", function() { return AddEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddOperation\", function() { return AddOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AdditiveBlending\", function() { return AdditiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlphaFormat\", function() { return AlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlwaysDepth\", function() { return AlwaysDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbientLight\", function() { return AmbientLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbientLightProbe\", function() { return AmbientLightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationClip\", function() { return AnimationClip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationLoader\", function() { return AnimationLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationMixer\", function() { return AnimationMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationObjectGroup\", function() { return AnimationObjectGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationUtils\", function() { return AnimationUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcCurve\", function() { return ArcCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayCamera\", function() { return ArrayCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrowHelper\", function() { return ArrowHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioAnalyser\", function() { return AudioAnalyser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioContext\", function() { return AudioContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioListener\", function() { return AudioListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioLoader\", function() { return AudioLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxesHelper\", function() { return AxesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxisHelper\", function() { return AxisHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackSide\", function() { return BackSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicDepthPacking\", function() { return BasicDepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicShadowMap\", function() { return BasicShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryTextureLoader\", function() { return BinaryTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bone\", function() { return Bone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanKeyframeTrack\", function() { return BooleanKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundingBoxHelper\", function() { return BoundingBoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box2\", function() { return Box2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3\", function() { return Box3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3Helper\", function() { return Box3Helper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxBufferGeometry\", function() { return BoxBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxHelper\", function() { return BoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferAttribute\", function() { return BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometry\", function() { return BufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometryLoader\", function() { return BufferGeometryLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteType\", function() { return ByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cache\", function() { return Cache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CameraHelper\", function() { return CameraHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRenderer\", function() { return CanvasRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasTexture\", function() { return CanvasTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CatmullRomCurve3\", function() { return CatmullRomCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CineonToneMapping\", function() { return CineonToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleBufferGeometry\", function() { return CircleBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleGeometry\", function() { return CircleGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClampToEdgeWrapping\", function() { return ClampToEdgeWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return Clock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClosedSplineCurve3\", function() { return ClosedSplineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorKeyframeTrack\", function() { return ColorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTexture\", function() { return CompressedTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTextureLoader\", function() { return CompressedTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeBufferGeometry\", function() { return ConeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeGeometry\", function() { return ConeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeCamera\", function() { return CubeCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeReflectionMapping\", function() { return CubeReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeRefractionMapping\", function() { return CubeRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTexture\", function() { return CubeTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTextureLoader\", function() { return CubeTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVReflectionMapping\", function() { return CubeUVReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVRefractionMapping\", function() { return CubeUVRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve\", function() { return CubicBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve3\", function() { return CubicBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicInterpolant\", function() { return CubicInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceBack\", function() { return CullFaceBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFront\", function() { return CullFaceFront; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFrontBack\", function() { return CullFaceFrontBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceNone\", function() { return CullFaceNone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Curve\", function() { return Curve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CurvePath\", function() { return CurvePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomBlending\", function() { return CustomBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderBufferGeometry\", function() { return CylinderBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderGeometry\", function() { return CylinderGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cylindrical\", function() { return Cylindrical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture\", function() { return DataTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture2DArray\", function() { return DataTexture2DArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture3D\", function() { return DataTexture3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTextureLoader\", function() { return DataTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultLoadingManager\", function() { return DefaultLoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthFormat\", function() { return DepthFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthStencilFormat\", function() { return DepthStencilFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthTexture\", function() { return DepthTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLight\", function() { return DirectionalLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLightHelper\", function() { return DirectionalLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLightShadow\", function() { return DirectionalLightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscreteInterpolant\", function() { return DiscreteInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronBufferGeometry\", function() { return DodecahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronGeometry\", function() { return DodecahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoubleSide\", function() { return DoubleSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstAlphaFactor\", function() { return DstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstColorFactor\", function() { return DstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicBufferAttribute\", function() { return DynamicBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesGeometry\", function() { return EdgesGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesHelper\", function() { return EdgesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EllipseCurve\", function() { return EllipseCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EqualDepth\", function() { return EqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularReflectionMapping\", function() { return EquirectangularReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularRefractionMapping\", function() { return EquirectangularRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Euler\", function() { return Euler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeBufferGeometry\", function() { return ExtrudeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeGeometry\", function() { return ExtrudeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Face3\", function() { return Face3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Face4\", function() { return Face4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceColors\", function() { return FaceColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceNormalsHelper\", function() { return FaceNormalsHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FileLoader\", function() { return FileLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatShading\", function() { return FlatShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32Attribute\", function() { return Float32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32BufferAttribute\", function() { return Float32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64Attribute\", function() { return Float64Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64BufferAttribute\", function() { return Float64BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FloatType\", function() { return FloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fog\", function() { return Fog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FogExp2\", function() { return FogExp2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Font\", function() { return Font; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FontLoader\", function() { return FontLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontFaceDirectionCCW\", function() { return FrontFaceDirectionCCW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontFaceDirectionCW\", function() { return FrontFaceDirectionCW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontSide\", function() { return FrontSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return Frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GammaEncoding\", function() { return GammaEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Geometry\", function() { return Geometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeometryUtils\", function() { return GeometryUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterDepth\", function() { return GreaterDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterEqualDepth\", function() { return GreaterEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GridHelper\", function() { return GridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return Group; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HalfFloatType\", function() { return HalfFloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLight\", function() { return HemisphereLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLightHelper\", function() { return HemisphereLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLightProbe\", function() { return HemisphereLightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronBufferGeometry\", function() { return IcosahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronGeometry\", function() { return IcosahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageBitmapLoader\", function() { return ImageBitmapLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageLoader\", function() { return ImageLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageUtils\", function() { return ImageUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImmediateRenderObject\", function() { return ImmediateRenderObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferAttribute\", function() { return InstancedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferGeometry\", function() { return InstancedBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedInterleavedBuffer\", function() { return InstancedInterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16Attribute\", function() { return Int16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16BufferAttribute\", function() { return Int16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32Attribute\", function() { return Int32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32BufferAttribute\", function() { return Int32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8Attribute\", function() { return Int8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8BufferAttribute\", function() { return Int8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntType\", function() { return IntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBuffer\", function() { return InterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBufferAttribute\", function() { return InterleavedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolant\", function() { return Interpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateDiscrete\", function() { return InterpolateDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateLinear\", function() { return InterpolateLinear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateSmooth\", function() { return InterpolateSmooth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSONLoader\", function() { return JSONLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyframeTrack\", function() { return KeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOD\", function() { return LOD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheBufferGeometry\", function() { return LatheBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheGeometry\", function() { return LatheGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layers\", function() { return Layers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LensFlare\", function() { return LensFlare; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessDepth\", function() { return LessDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessEqualDepth\", function() { return LessEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Light\", function() { return Light; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightProbe\", function() { return LightProbe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightProbeHelper\", function() { return LightProbeHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightShadow\", function() { return LightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line3\", function() { return Line3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineBasicMaterial\", function() { return LineBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve\", function() { return LineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve3\", function() { return LineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineDashedMaterial\", function() { return LineDashedMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLoop\", function() { return LineLoop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinePieces\", function() { return LinePieces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineSegments\", function() { return LineSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineStrip\", function() { return LineStrip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearEncoding\", function() { return LinearEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearFilter\", function() { return LinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearInterpolant\", function() { return LinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapLinearFilter\", function() { return LinearMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapNearestFilter\", function() { return LinearMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearToneMapping\", function() { return LinearToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return Loader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoaderUtils\", function() { return LoaderUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadingManager\", function() { return LoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLuvEncoding\", function() { return LogLuvEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopOnce\", function() { return LoopOnce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopPingPong\", function() { return LoopPingPong; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopRepeat\", function() { return LoopRepeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceAlphaFormat\", function() { return LuminanceAlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceFormat\", function() { return LuminanceFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MOUSE\", function() { return MOUSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return Material; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaterialLoader\", function() { return MaterialLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Math\", function() { return _Math; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix3\", function() { return Matrix3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaxEquation\", function() { return MaxEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshBasicMaterial\", function() { return MeshBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDepthMaterial\", function() { return MeshDepthMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDistanceMaterial\", function() { return MeshDistanceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshFaceMaterial\", function() { return MeshFaceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshLambertMaterial\", function() { return MeshLambertMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshMatcapMaterial\", function() { return MeshMatcapMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshNormalMaterial\", function() { return MeshNormalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhongMaterial\", function() { return MeshPhongMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhysicalMaterial\", function() { return MeshPhysicalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshStandardMaterial\", function() { return MeshStandardMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshToonMaterial\", function() { return MeshToonMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinEquation\", function() { return MinEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MirroredRepeatWrapping\", function() { return MirroredRepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixOperation\", function() { return MixOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiMaterial\", function() { return MultiMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyBlending\", function() { return MultiplyBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyOperation\", function() { return MultiplyOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestFilter\", function() { return NearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapLinearFilter\", function() { return NearestMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapNearestFilter\", function() { return NearestMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeverDepth\", function() { return NeverDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoBlending\", function() { return NoBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoColors\", function() { return NoColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoToneMapping\", function() { return NoToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalBlending\", function() { return NormalBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotEqualDepth\", function() { return NotEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumberKeyframeTrack\", function() { return NumberKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Object3D\", function() { return Object3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectLoader\", function() { return ObjectLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectSpaceNormalMap\", function() { return ObjectSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronBufferGeometry\", function() { return OctahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronGeometry\", function() { return OctahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneFactor\", function() { return OneFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstAlphaFactor\", function() { return OneMinusDstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstColorFactor\", function() { return OneMinusDstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcAlphaFactor\", function() { return OneMinusSrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcColorFactor\", function() { return OneMinusSrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicCamera\", function() { return OrthographicCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFShadowMap\", function() { return PCFShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFSoftShadowMap\", function() { return PCFSoftShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricBufferGeometry\", function() { return ParametricBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricGeometry\", function() { return ParametricGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Particle\", function() { return Particle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleBasicMaterial\", function() { return ParticleBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystem\", function() { return ParticleSystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystemMaterial\", function() { return ParticleSystemMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerspectiveCamera\", function() { return PerspectiveCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneBufferGeometry\", function() { return PlaneBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneGeometry\", function() { return PlaneGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneHelper\", function() { return PlaneHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloud\", function() { return PointCloud; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloudMaterial\", function() { return PointCloudMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLight\", function() { return PointLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLightHelper\", function() { return PointLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Points\", function() { return Points; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointsMaterial\", function() { return PointsMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolarGridHelper\", function() { return PolarGridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronBufferGeometry\", function() { return PolyhedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronGeometry\", function() { return PolyhedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionalAudio\", function() { return PositionalAudio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionalAudioHelper\", function() { return PositionalAudioHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyBinding\", function() { return PropertyBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyMixer\", function() { return PropertyMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve\", function() { return QuadraticBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve3\", function() { return QuadraticBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionKeyframeTrack\", function() { return QuaternionKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionLinearInterpolant\", function() { return QuaternionLinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVISION\", function() { return REVISION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBADepthPacking\", function() { return RGBADepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBAFormat\", function() { return RGBAFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x10_Format\", function() { return RGBA_ASTC_10x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x5_Format\", function() { return RGBA_ASTC_10x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x6_Format\", function() { return RGBA_ASTC_10x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x8_Format\", function() { return RGBA_ASTC_10x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x10_Format\", function() { return RGBA_ASTC_12x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x12_Format\", function() { return RGBA_ASTC_12x12_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_4x4_Format\", function() { return RGBA_ASTC_4x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x4_Format\", function() { return RGBA_ASTC_5x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x5_Format\", function() { return RGBA_ASTC_5x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x5_Format\", function() { return RGBA_ASTC_6x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x6_Format\", function() { return RGBA_ASTC_6x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x5_Format\", function() { return RGBA_ASTC_8x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x6_Format\", function() { return RGBA_ASTC_8x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x8_Format\", function() { return RGBA_ASTC_8x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_2BPPV1_Format\", function() { return RGBA_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_4BPPV1_Format\", function() { return RGBA_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT1_Format\", function() { return RGBA_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT3_Format\", function() { return RGBA_S3TC_DXT3_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT5_Format\", function() { return RGBA_S3TC_DXT5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBDEncoding\", function() { return RGBDEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEEncoding\", function() { return RGBEEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEFormat\", function() { return RGBEFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBFormat\", function() { return RGBFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM16Encoding\", function() { return RGBM16Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM7Encoding\", function() { return RGBM7Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_ETC1_Format\", function() { return RGB_ETC1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_2BPPV1_Format\", function() { return RGB_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_4BPPV1_Format\", function() { return RGB_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_S3TC_DXT1_Format\", function() { return RGB_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RawShaderMaterial\", function() { return RawShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ray\", function() { return Ray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Raycaster\", function() { return Raycaster; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectAreaLight\", function() { return RectAreaLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectAreaLightHelper\", function() { return RectAreaLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedFormat\", function() { return RedFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReinhardToneMapping\", function() { return ReinhardToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepeatWrapping\", function() { return RepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReverseSubtractEquation\", function() { return ReverseSubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingBufferGeometry\", function() { return RingBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingGeometry\", function() { return RingGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneUtils\", function() { return SceneUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderChunk\", function() { return ShaderChunk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderLib\", function() { return ShaderLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderMaterial\", function() { return ShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowMaterial\", function() { return ShadowMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shape\", function() { return Shape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeBufferGeometry\", function() { return ShapeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeGeometry\", function() { return ShapeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapePath\", function() { return ShapePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeUtils\", function() { return ShapeUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShortType\", function() { return ShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Skeleton\", function() { return Skeleton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkeletonHelper\", function() { return SkeletonHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkinnedMesh\", function() { return SkinnedMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SmoothShading\", function() { return SmoothShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sphere\", function() { return Sphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereBufferGeometry\", function() { return SphereBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereGeometry\", function() { return SphereGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spherical\", function() { return Spherical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphericalHarmonics3\", function() { return SphericalHarmonics3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphericalReflectionMapping\", function() { return SphericalReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spline\", function() { return Spline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplineCurve\", function() { return SplineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplineCurve3\", function() { return SplineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLight\", function() { return SpotLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLightHelper\", function() { return SpotLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLightShadow\", function() { return SpotLightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sprite\", function() { return Sprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpriteMaterial\", function() { return SpriteMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaFactor\", function() { return SrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaSaturateFactor\", function() { return SrcAlphaSaturateFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcColorFactor\", function() { return SrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StereoCamera\", function() { return StereoCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringKeyframeTrack\", function() { return StringKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractEquation\", function() { return SubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractiveBlending\", function() { return SubtractiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TangentSpaceNormalMap\", function() { return TangentSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronBufferGeometry\", function() { return TetrahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronGeometry\", function() { return TetrahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextBufferGeometry\", function() { return TextBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextGeometry\", function() { return TextGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureLoader\", function() { return TextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusBufferGeometry\", function() { return TorusBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusGeometry\", function() { return TorusGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotBufferGeometry\", function() { return TorusKnotBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotGeometry\", function() { return TorusKnotGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Triangle\", function() { return Triangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleFanDrawMode\", function() { return TriangleFanDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleStripDrawMode\", function() { return TriangleStripDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrianglesDrawMode\", function() { return TrianglesDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeBufferGeometry\", function() { return TubeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeGeometry\", function() { return TubeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UVMapping\", function() { return UVMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16Attribute\", function() { return Uint16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16BufferAttribute\", function() { return Uint16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32Attribute\", function() { return Uint32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32BufferAttribute\", function() { return Uint32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8Attribute\", function() { return Uint8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8BufferAttribute\", function() { return Uint8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedAttribute\", function() { return Uint8ClampedAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedBufferAttribute\", function() { return Uint8ClampedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uncharted2ToneMapping\", function() { return Uncharted2ToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uniform\", function() { return Uniform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsLib\", function() { return UniformsLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsUtils\", function() { return UniformsUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedByteType\", function() { return UnsignedByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedInt248Type\", function() { return UnsignedInt248Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedIntType\", function() { return UnsignedIntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort4444Type\", function() { return UnsignedShort4444Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort5551Type\", function() { return UnsignedShort5551Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort565Type\", function() { return UnsignedShort565Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShortType\", function() { return UnsignedShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VectorKeyframeTrack\", function() { return VectorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return Vertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexColors\", function() { return VertexColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexNormalsHelper\", function() { return VertexNormalsHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VideoTexture\", function() { return VideoTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLMultisampleRenderTarget\", function() { return WebGLMultisampleRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTarget\", function() { return WebGLRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTargetCube\", function() { return WebGLRenderTargetCube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderer\", function() { return WebGLRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLUtils\", function() { return WebGLUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeGeometry\", function() { return WireframeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeHelper\", function() { return WireframeHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrapAroundEnding\", function() { return WrapAroundEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XHRLoader\", function() { return XHRLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroCurvatureEnding\", function() { return ZeroCurvatureEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroFactor\", function() { return ZeroFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroSlopeEnding\", function() { return ZeroSlopeEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sRGBEncoding\", function() { return sRGBEncoding; });\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\nif ( Number.isInteger === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\n\tNumber.isInteger = function ( value ) {\n\n\t\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\n\n\t};\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( 'name' in Function.prototype === false ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nfunction EventDispatcher() {}\n\nObject.assign( EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = listenerArray.slice( 0 );\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nvar REVISION = '106';\nvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\nvar CullFaceNone = 0;\nvar CullFaceBack = 1;\nvar CullFaceFront = 2;\nvar CullFaceFrontBack = 3;\nvar FrontFaceDirectionCW = 0;\nvar FrontFaceDirectionCCW = 1;\nvar BasicShadowMap = 0;\nvar PCFShadowMap = 1;\nvar PCFSoftShadowMap = 2;\nvar FrontSide = 0;\nvar BackSide = 1;\nvar DoubleSide = 2;\nvar FlatShading = 1;\nvar SmoothShading = 2;\nvar NoColors = 0;\nvar FaceColors = 1;\nvar VertexColors = 2;\nvar NoBlending = 0;\nvar NormalBlending = 1;\nvar AdditiveBlending = 2;\nvar SubtractiveBlending = 3;\nvar MultiplyBlending = 4;\nvar CustomBlending = 5;\nvar AddEquation = 100;\nvar SubtractEquation = 101;\nvar ReverseSubtractEquation = 102;\nvar MinEquation = 103;\nvar MaxEquation = 104;\nvar ZeroFactor = 200;\nvar OneFactor = 201;\nvar SrcColorFactor = 202;\nvar OneMinusSrcColorFactor = 203;\nvar SrcAlphaFactor = 204;\nvar OneMinusSrcAlphaFactor = 205;\nvar DstAlphaFactor = 206;\nvar OneMinusDstAlphaFactor = 207;\nvar DstColorFactor = 208;\nvar OneMinusDstColorFactor = 209;\nvar SrcAlphaSaturateFactor = 210;\nvar NeverDepth = 0;\nvar AlwaysDepth = 1;\nvar LessDepth = 2;\nvar LessEqualDepth = 3;\nvar EqualDepth = 4;\nvar GreaterEqualDepth = 5;\nvar GreaterDepth = 6;\nvar NotEqualDepth = 7;\nvar MultiplyOperation = 0;\nvar MixOperation = 1;\nvar AddOperation = 2;\nvar NoToneMapping = 0;\nvar LinearToneMapping = 1;\nvar ReinhardToneMapping = 2;\nvar Uncharted2ToneMapping = 3;\nvar CineonToneMapping = 4;\nvar ACESFilmicToneMapping = 5;\n\nvar UVMapping = 300;\nvar CubeReflectionMapping = 301;\nvar CubeRefractionMapping = 302;\nvar EquirectangularReflectionMapping = 303;\nvar EquirectangularRefractionMapping = 304;\nvar SphericalReflectionMapping = 305;\nvar CubeUVReflectionMapping = 306;\nvar CubeUVRefractionMapping = 307;\nvar RepeatWrapping = 1000;\nvar ClampToEdgeWrapping = 1001;\nvar MirroredRepeatWrapping = 1002;\nvar NearestFilter = 1003;\nvar NearestMipMapNearestFilter = 1004;\nvar NearestMipMapLinearFilter = 1005;\nvar LinearFilter = 1006;\nvar LinearMipMapNearestFilter = 1007;\nvar LinearMipMapLinearFilter = 1008;\nvar UnsignedByteType = 1009;\nvar ByteType = 1010;\nvar ShortType = 1011;\nvar UnsignedShortType = 1012;\nvar IntType = 1013;\nvar UnsignedIntType = 1014;\nvar FloatType = 1015;\nvar HalfFloatType = 1016;\nvar UnsignedShort4444Type = 1017;\nvar UnsignedShort5551Type = 1018;\nvar UnsignedShort565Type = 1019;\nvar UnsignedInt248Type = 1020;\nvar AlphaFormat = 1021;\nvar RGBFormat = 1022;\nvar RGBAFormat = 1023;\nvar LuminanceFormat = 1024;\nvar LuminanceAlphaFormat = 1025;\nvar RGBEFormat = RGBAFormat;\nvar DepthFormat = 1026;\nvar DepthStencilFormat = 1027;\nvar RedFormat = 1028;\nvar RGB_S3TC_DXT1_Format = 33776;\nvar RGBA_S3TC_DXT1_Format = 33777;\nvar RGBA_S3TC_DXT3_Format = 33778;\nvar RGBA_S3TC_DXT5_Format = 33779;\nvar RGB_PVRTC_4BPPV1_Format = 35840;\nvar RGB_PVRTC_2BPPV1_Format = 35841;\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\nvar RGBA_PVRTC_2BPPV1_Format = 35843;\nvar RGB_ETC1_Format = 36196;\nvar RGBA_ASTC_4x4_Format = 37808;\nvar RGBA_ASTC_5x4_Format = 37809;\nvar RGBA_ASTC_5x5_Format = 37810;\nvar RGBA_ASTC_6x5_Format = 37811;\nvar RGBA_ASTC_6x6_Format = 37812;\nvar RGBA_ASTC_8x5_Format = 37813;\nvar RGBA_ASTC_8x6_Format = 37814;\nvar RGBA_ASTC_8x8_Format = 37815;\nvar RGBA_ASTC_10x5_Format = 37816;\nvar RGBA_ASTC_10x6_Format = 37817;\nvar RGBA_ASTC_10x8_Format = 37818;\nvar RGBA_ASTC_10x10_Format = 37819;\nvar RGBA_ASTC_12x10_Format = 37820;\nvar RGBA_ASTC_12x12_Format = 37821;\nvar LoopOnce = 2200;\nvar LoopRepeat = 2201;\nvar LoopPingPong = 2202;\nvar InterpolateDiscrete = 2300;\nvar InterpolateLinear = 2301;\nvar InterpolateSmooth = 2302;\nvar ZeroCurvatureEnding = 2400;\nvar ZeroSlopeEnding = 2401;\nvar WrapAroundEnding = 2402;\nvar TrianglesDrawMode = 0;\nvar TriangleStripDrawMode = 1;\nvar TriangleFanDrawMode = 2;\nvar LinearEncoding = 3000;\nvar sRGBEncoding = 3001;\nvar GammaEncoding = 3007;\nvar RGBEEncoding = 3002;\nvar LogLuvEncoding = 3003;\nvar RGBM7Encoding = 3004;\nvar RGBM16Encoding = 3005;\nvar RGBDEncoding = 3006;\nvar BasicDepthPacking = 3200;\nvar RGBADepthPacking = 3201;\nvar TangentSpaceNormalMap = 0;\nvar ObjectSpaceNormalMap = 1;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: ( function () {\n\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\tvar lut = [];\n\n\t\tfor ( var i = 0; i < 256; i ++ ) {\n\n\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n\t\t}\n\n\t\treturn function generateUUID() {\n\n\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\n\t\t\tvar uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\n\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\n\n\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\t\t\treturn uuid.toUpperCase();\n\n\t\t};\n\n\t} )(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\tlerp: function ( x, y, t ) {\n\n\t\treturn ( 1 - t ) * x + t * y;\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * _Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * _Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tceilPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tfloorPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nfunction Vector2( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n}\n\nObject.defineProperties( Vector2.prototype, {\n\n\t\"width\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t}\n\n\t},\n\n\t\"height\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Vector2.prototype, {\n\n\tisVector2: true,\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function ( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tcross: function ( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tmanhattanDistanceTo: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nfunction Quaternion( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n}\n\nObject.assign( Quaternion, {\n\n\tslerp: function ( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\nObject.defineProperties( Quaternion.prototype, {\n\n\tx: {\n\n\t\tget: function () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\ty: {\n\n\t\tget: function () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tz: {\n\n\t\tget: function () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tw: {\n\n\t\tget: function () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Quaternion.prototype, {\n\n\tisQuaternion: true,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar cos = Math.cos;\n\t\tvar sin = Math.sin;\n\n\t\tvar c1 = cos( x / 2 );\n\t\tvar c2 = cos( y / 2 );\n\t\tvar c3 = cos( z / 2 );\n\n\t\tvar s1 = sin( x / 2 );\n\t\tvar s2 = sin( y / 2 );\n\t\tvar s3 = sin( z / 2 );\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function ( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar EPS = 0.000001;\n\n\t\tvar r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < EPS ) {\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t},\n\n\tangleTo: function ( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t},\n\n\trotateTowards: function ( q, step ) {\n\n\t\tvar angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tvar t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tvar s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\t_onChange: function ( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\t_onChangeCallback: function () {}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Vector3( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n}\n\nObject.assign( Vector3.prototype, {\n\n\tisVector3: true,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix = qw * x + qy * z - qz * y;\n\t\tvar iy = qw * y + qz * x - qx * z;\n\t\tvar iz = qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function ( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t},\n\n\tunproject: function ( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t},\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function ( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\t// TODO lengthSquared?\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\treturn this.crossVectors( this, v );\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function reflect( normal ) {\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tmanhattanDistanceTo: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t},\n\n\tsetFromSpherical: function ( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t},\n\n\tsetFromSphericalCoords: function ( radius, phi, theta ) {\n\n\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCylindrical: function ( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t},\n\n\tsetFromCylindricalCoords: function ( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nfunction Matrix3() {\n\n\tthis.elements = [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t];\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n}\n\nObject.assign( Matrix3.prototype, {\n\n\tisMatrix3: true,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToBufferAttribute: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn attribute;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix && matrix.isMatrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tvar c = Math.cos( rotation );\n\t\tvar s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t},\n\n\tscale: function ( sx, sy ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\treturn this;\n\n\t},\n\n\trotate: function ( theta ) {\n\n\t\tvar c = Math.cos( theta );\n\t\tvar s = Math.sin( theta );\n\n\t\tvar te = this.elements;\n\n\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\tte[ 0 ] = c * a11 + s * a21;\n\t\tte[ 3 ] = c * a12 + s * a22;\n\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( tx, ty ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nvar _canvas;\n\nvar ImageUtils = {\n\n\tgetDataURL: function ( image ) {\n\n\t\tvar canvas;\n\n\t\tif ( typeof HTMLCanvasElement == 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t} else if ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tvar context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nvar textureId = 0;\n\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : RGBAFormat;\n\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\tthis.offset = new Vector2( 0, 0 );\n\tthis.repeat = new Vector2( 1, 1 );\n\tthis.center = new Vector2( 0, 0 );\n\tthis.rotation = 0;\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrix = new Matrix3();\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Texture,\n\n\tisTexture: true,\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tvar output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tvar url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( var i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\turl.push( ImageUtils.getDataURL( image[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = ImageUtils.getDataURL( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n} );\n\nObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Vector4( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n}\n\nObject.defineProperties( Vector4.prototype, {\n\n\t\"width\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.z;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.z = value;\n\n\t\t}\n\n\t},\n\n\t\"height\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.w;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.w = value;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Vector4.prototype, {\n\n\tisVector4: true,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new Vector4();\n\t\t\t\tmax = new Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nfunction WebGLRenderTarget( width, height, options ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.texture.image = {};\n\tthis.texture.image.width = width;\n\tthis.texture.image.height = height;\n\n\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n}\n\nWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: WebGLRenderTarget,\n\n\tisWebGLRenderTarget: true,\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n * @author Matt DesLauriers / @mattdesl\n */\n\nfunction WebGLMultisampleRenderTarget( width, height, options ) {\n\n\tWebGLRenderTarget.call( this, width, height, options );\n\n\tthis.samples = 4;\n\n}\n\nWebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {\n\n\tconstructor: WebGLMultisampleRenderTarget,\n\n\tisWebGLMultisampleRenderTarget: true,\n\n\tcopy: function ( source ) {\n\n\t\tWebGLRenderTarget.prototype.copy.call( this, source );\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Matrix4() {\n\n\tthis.elements = [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t];\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n}\n\nObject.assign( Matrix4.prototype, {\n\n\tisMatrix4: true,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\t// this method does not support reflection matrices\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\t\tte[ 3 ] = 0;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\t\tte[ 7 ] = 0;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function () {\n\n\t\tvar zero = new Vector3( 0, 0, 0 );\n\t\tvar one = new Vector3( 1, 1, 1 );\n\n\t\treturn function makeRotationFromQuaternion( q ) {\n\n\t\t\treturn this.compose( zero, q, one );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar x = new Vector3();\n\t\tvar y = new Vector3();\n\t\tvar z = new Vector3();\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target );\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t// eye and target are in the same position\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tz.normalize();\n\t\t\tx.crossVectors( up, z );\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t// up and z are parallel\n\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t\tz.x += 0.0001;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz.z += 0.0001;\n\n\t\t\t\t}\n\n\t\t\t\tz.normalize();\n\t\t\t\tx.crossVectors( up, z );\n\n\t\t\t}\n\n\t\t\tx.normalize();\n\t\t\ty.crossVectors( z, x );\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToBufferAttribute: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn attribute;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tsetPosition: function ( x, y, z ) {\n\n\t\tvar te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeShear: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, y, z, 0,\n\t\t\tx, 1, z, 0,\n\t\t\tx, y, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar matrix = new Matrix4();\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) sx = - sx;\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\t\t\tmatrix.copy( this );\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakePerspective: function ( left, right, top, bottom, near, far ) {\n\n\t\tif ( far === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nfunction Euler( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || Euler.DefaultOrder;\n\n}\n\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nEuler.DefaultOrder = 'XYZ';\n\nObject.defineProperties( Euler.prototype, {\n\n\tx: {\n\n\t\tget: function () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\ty: {\n\n\t\tget: function () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tz: {\n\n\t\tget: function () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t},\n\n\torder: {\n\n\t\tget: function () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Euler.prototype, {\n\n\tisEuler: true,\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = _Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix = new Matrix4();\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\t_onChange: function ( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\t_onChangeCallback: function () {}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Layers() {\n\n\tthis.mask = 1 | 0;\n\n}\n\nObject.assign( Layers.prototype, {\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel | 0;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nvar object3DId = 0;\n\nfunction Object3D() {\n\n\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = Object3D.DefaultUp.clone();\n\n\tvar position = new Vector3();\n\tvar rotation = new Euler();\n\tvar quaternion = new Quaternion();\n\tvar scale = new Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation._onChange( onRotationChange );\n\tquaternion._onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new Matrix4();\n\tthis.matrixWorld = new Matrix4();\n\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n}\n\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Object3D,\n\n\tisObject3D: true,\n\n\tonBeforeRender: function () {},\n\tonAfterRender: function () {},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateOnWorldAxis: function () {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\tvar q1 = new Quaternion();\n\n\t\treturn function rotateOnWorldAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.premultiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tvar q1 = new Quaternion();\n\t\tvar m1 = new Matrix4();\n\t\tvar target = new Vector3();\n\t\tvar position = new Vector3();\n\n\t\treturn function lookAt( x, y, z ) {\n\n\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\ttarget.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.set( x, y, z );\n\n\t\t\t}\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t\tm1.lookAt( position, target, this.up );\n\n\t\t\t} else {\n\n\t\t\t\tm1.lookAt( target, position, this.up );\n\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tm1.extractRotation( parent.matrixWorld );\n\t\t\t\tq1.setFromRotationMatrix( m1 );\n\t\t\t\tthis.quaternion.premultiply( q1.inverse() );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( ( object && object.isObject3D ) ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tattach: function () {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\tvar m = new Matrix4();\n\n\t\treturn function attach( object ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tm.getInverse( this.matrixWorld );\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t\tm.multiply( object.parent.matrixWorld );\n\n\t\t\t}\n\n\t\t\tobject.applyMatrix( m );\n\n\t\t\tobject.updateWorldMatrix( false, false );\n\n\t\t\tthis.add( object );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new Vector3();\n\t\tvar scale = new Vector3();\n\n\t\treturn function getWorldQuaternion( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );\n\t\t\t\ttarget = new Quaternion();\n\n\t\t\t}\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, target, scale );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldScale( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getWorldScale() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, target );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\tvar e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t},\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tvar parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tvar shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tvar uuids = [];\n\n\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\t\t\tvar shapes = extractFromCache( meta.shapes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Scene() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t}\n\n}\n\nScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Scene,\n\n\tisScene: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Box3( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n}\n\nObject.assign( Box3.prototype, {\n\n\tisBox3: true,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromBufferAttribute: function ( attribute ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tvar x = attribute.getX( i );\n\t\t\tvar y = attribute.getY( i );\n\t\t\tvar z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function ( object ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tgetSize: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getSize() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\texpandByObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar scope, i, l;\n\n\t\tvar v1 = new Vector3();\n\n\t\tfunction traverse( node ) {\n\n\t\t\tvar geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function expandByObject( object ) {\n\n\t\t\tscope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( traverse );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t},\n\n\tgetParameter: function ( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getParameter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint = new Vector3();\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t},\n\n\tintersectsTriangle: ( function () {\n\n\t\t// triangle centered vertices\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\t// triangle edge vectors\n\t\tvar f0 = new Vector3();\n\t\tvar f1 = new Vector3();\n\t\tvar f2 = new Vector3();\n\n\t\tvar testAxis = new Vector3();\n\n\t\tvar center = new Vector3();\n\t\tvar extents = new Vector3();\n\n\t\tvar triangleNormal = new Vector3();\n\n\t\tfunction satForAxes( axes ) {\n\n\t\t\tvar i, j;\n\n\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t\t\ttestAxis.fromArray( axes, i );\n\t\t\t\t// project the aabb onto the seperating axis\n\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\n\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\t\t\tvar p0 = v0.dot( testAxis );\n\t\t\t\tvar p1 = v1.dot( testAxis );\n\t\t\t\tvar p2 = v2.dot( testAxis );\n\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.isEmpty() ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// compute box center and extents\n\t\t\tthis.getCenter( center );\n\t\t\textents.subVectors( this.max, center );\n\n\t\t\t// translate triangle to aabb origin\n\t\t\tv0.subVectors( triangle.a, center );\n\t\t\tv1.subVectors( triangle.b, center );\n\t\t\tv2.subVectors( triangle.c, center );\n\n\t\t\t// compute edge vectors for triangle\n\t\t\tf0.subVectors( v1, v0 );\n\t\t\tf1.subVectors( v2, v1 );\n\t\t\tf2.subVectors( v0, v2 );\n\n\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\t\tvar axes = [\n\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\n\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\n\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\n\t\t\t];\n\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// test 3 face normals from the aabb\n\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// finally testing the face normal of the triangle\n\t\t\t// use already existing triangle edge vectors here\n\t\t\ttriangleNormal.crossVectors( f0, f1 );\n\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\n\t\t\treturn satForAxes( axes );\n\n\t\t};\n\n\t} )(),\n\n\tclampPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function getBoundingSphere( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.Box3: .getBoundingSphere() target is now required' );\n\t\t\t\t//target = new Sphere(); // removed to avoid cyclic dependency\n\n\t\t\t}\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif ( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Sphere( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n}\n\nObject.assign( Sphere.prototype, {\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, target ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t},\n\n\tgetBoundingBox: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\n\t\t\ttarget = new Box3();\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Ray( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n}\n\nObject.assign( Ray.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tvar directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new Vector3();\n\t\tvar segDir = new Vector3();\n\t\tvar diff = new Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function intersectSphere( sphere, target ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, target );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t},\n\n\tintersectPlane: function ( plane, target ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, target ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new Vector3();\n\t\tvar edge1 = new Vector3();\n\t\tvar edge2 = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, target );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Triangle( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n}\n\nObject.assign( Triangle, {\n\n\tgetNormal: function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function getNormal( a, b, c, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\ttarget.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\ttarget.cross( v0 );\n\n\t\t\tvar targetLengthSq = target.lengthSq();\n\t\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn target.set( 0, 0, 0 );\n\n\t\t};\n\n\t}(),\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tgetBarycoord: function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function getBarycoord( point, a, b, c, target ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn target.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tTriangle.getBarycoord( point, a, b, c, v1 );\n\n\t\t\treturn ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );\n\n\t\t};\n\n\t}(),\n\n\tgetUV: function () {\n\n\t\tvar barycoord = new Vector3();\n\n\t\treturn function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\t\tthis.getBarycoord( point, p1, p2, p3, barycoord );\n\n\t\t\ttarget.set( 0, 0 );\n\t\t\ttarget.addScaledVector( uv1, barycoord.x );\n\t\t\ttarget.addScaledVector( uv2, barycoord.y );\n\t\t\ttarget.addScaledVector( uv3, barycoord.z );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tisFrontFacing: function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\n\t\treturn function isFrontFacing( a, b, c, direction ) {\n\n\t\t\tv0.subVectors( c, b );\n\t\t\tv1.subVectors( a, b );\n\n\t\t\t// strictly front facing\n\t\t\treturn ( v0.cross( v1 ).dot( direction ) < 0 ) ? true : false;\n\n\t\t};\n\n\t}()\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tgetArea: function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\n\t\treturn function getArea() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tgetMidpoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tgetNormal: function ( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t},\n\n\tgetPlane: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tgetBarycoord: function ( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t},\n\n\tgetUV: function ( point, uv1, uv2, uv3, target ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tisFrontFacing: function ( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar vab = new Vector3();\n\t\tvar vac = new Vector3();\n\t\tvar vbc = new Vector3();\n\t\tvar vap = new Vector3();\n\t\tvar vbp = new Vector3();\n\t\tvar vcp = new Vector3();\n\n\t\treturn function closestPointToPoint( p, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tvar a = this.a, b = this.b, c = this.c;\n\t\t\tvar v, w;\n\n\t\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t\tvab.subVectors( b, a );\n\t\t\tvac.subVectors( c, a );\n\t\t\tvap.subVectors( p, a );\n\t\t\tvar d1 = vab.dot( vap );\n\t\t\tvar d2 = vac.dot( vap );\n\t\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\t\treturn target.copy( a );\n\n\t\t\t}\n\n\t\t\tvbp.subVectors( p, b );\n\t\t\tvar d3 = vab.dot( vbp );\n\t\t\tvar d4 = vac.dot( vbp );\n\t\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\t\treturn target.copy( b );\n\n\t\t\t}\n\n\t\t\tvar vc = d1 * d4 - d3 * d2;\n\t\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\t\treturn target.copy( a ).addScaledVector( vab, v );\n\n\t\t\t}\n\n\t\t\tvcp.subVectors( p, c );\n\t\t\tvar d5 = vab.dot( vcp );\n\t\t\tvar d6 = vac.dot( vcp );\n\t\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\t\treturn target.copy( c );\n\n\t\t\t}\n\n\t\t\tvar vb = d5 * d2 - d1 * d6;\n\t\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\t\treturn target.copy( a ).addScaledVector( vac, w );\n\n\t\t\t}\n\n\t\t\tvar va = d3 * d6 - d5 * d4;\n\t\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t\tvbc.subVectors( c, b );\n\t\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\t\treturn target.copy( b ).addScaledVector( vbc, w ); // edge region of BC\n\n\t\t\t}\n\n\t\t\t// face region\n\t\t\tvar denom = 1 / ( va + vb + vc );\n\t\t\t// u = va * denom\n\t\t\tv = vb * denom;\n\t\t\tw = vc * denom;\n\t\t\treturn target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nfunction Color( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n}\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nObject.assign( Color.prototype, {\n\n\tisColor: true,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value && value.isColor ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function ( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = _Math.euclideanModulo( h, 1 );\n\t\ts = _Math.clamp( s, 0, 1 );\n\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function ( gammaFactor ) {\n\n\t\tthis.copyGammaToLinear( this, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function ( gammaFactor ) {\n\n\t\tthis.copyLinearToGamma( this, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopySRGBToLinear: function ( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToSRGB: function ( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tconvertSRGBToLinear: function () {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToSRGB: function () {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( target ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Color: .getHSL() target is now required' );\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\n\n\t\t}\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function () {\n\n\t\tvar hsl = {};\n\n\t\treturn function ( h, s, l ) {\n\n\t\t\tthis.getHSL( hsl );\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpHSL: function () {\n\n\t\tvar hslA = { h: 0, s: 0, l: 0 };\n\t\tvar hslB = { h: 0, s: 0, l: 0 };\n\n\t\treturn function lerpHSL( color, alpha ) {\n\n\t\t\tthis.getHSL( hslA );\n\t\t\tcolor.getHSL( hslB );\n\n\t\t\tvar h = _Math.lerp( hslA.h, hslB.h, alpha );\n\t\t\tvar s = _Math.lerp( hslA.s, hslB.s, alpha );\n\t\t\tvar l = _Math.lerp( hslA.l, hslB.l, alpha );\n\n\t\t\tthis.setHSL( h, s, l );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\treturn this.getHex();\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = ( color && color.isColor ) ? color : new Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n}\n\nObject.assign( Face3.prototype, {\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar materialId = 0;\n\nfunction Material() {\n\n\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = NormalBlending;\n\tthis.side = FrontSide;\n\tthis.flatShading = false;\n\tthis.vertexTangents = false;\n\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = SrcAlphaFactor;\n\tthis.blendDst = OneMinusSrcAlphaFactor;\n\tthis.blendEquation = AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipIntersection = false;\n\tthis.clipShadows = false;\n\n\tthis.shadowSide = null;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.dithering = false;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.visible = true;\n\n\tthis.userData = {};\n\n\tthis.needsUpdate = true;\n\n}\n\nMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Material,\n\n\tisMaterial: true,\n\n\tonBeforeCompile: function () {},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\tif ( key === 'shading' ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\n\t\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\t\tdata.refractionRatio = this.refractionRatio;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\t\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\n\t\t}\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\tdata.depthFunc = this.depthFunc;\n\t\tdata.depthTest = this.depthTest;\n\t\tdata.depthWrite = this.depthWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\tif ( this.morphNormals === true ) data.morphNormals = true;\n\t\tif ( this.skinning === true ) data.skinning = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.flatShading = source.flatShading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.visible = source.visible;\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.clipShadows = source.clipShadows;\n\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nfunction MeshBasicMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshBasicMaterial.prototype = Object.create( Material.prototype );\nMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction BufferAttribute( array, itemSize, normalized ) {\n\n\tif ( Array.isArray( array ) ) {\n\n\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t}\n\n\tthis.name = '';\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\tthis.normalized = normalized === true;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( BufferAttribute.prototype, {\n\n\tisBufferAttribute: true,\n\n\tonUploadCallback: function () {},\n\n\tsetArray: function ( array ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\tthis.array = array;\n\n\t\treturn this;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\treturn {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.prototype.slice.call( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t}\n\n} );\n\n//\n\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\n\n}\n\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\n\n}\n\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\n\n}\n\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\n\n}\n\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\n}\n\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\n\n}\n\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\n\n}\n\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\n\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\n\n}\n\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\n\n}\n\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction DirectGeometry() {\n\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nObject.assign( DirectGeometry.prototype, {\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex = undefined;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tvar max = array[ 0 ];\n\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\treturn this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToBufferAttribute( position );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToBufferAttribute( normal );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tvar tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t// Tangent is vec4, but the '.w' component is a sign value (+1/-1).\n\t\t\tnormalMatrix.applyToBufferAttribute( tangent );\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj = new Object3D();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tvar offset = new Vector3();\n\n\t\treturn function center() {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tvar position = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\tdirect = undefined;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tvar attribute;\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function computeBoundingBox() {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar position = this.attributes.position;\n\t\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t\t// process morph attributes if present\n\n\t\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t\tbox.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new Box3();\n\t\tvar boxMorphTargets = new Box3();\n\t\tvar vector = new Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tvar position = this.attributes.position;\n\t\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif ( position ) {\n\n\t\t\t\t// first, find the center of the bounding sphere\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromBufferAttribute( position );\n\n\t\t\t\t// process morph attributes if present\n\n\t\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t\tboxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\t\tbox.expandByPoint( boxMorphTargets.min );\n\t\t\t\t\t\tbox.expandByPoint( boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t\tvector.fromBufferAttribute( position, i );\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\t// process morph attributes if present\n\n\t\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeOffset = attribute2.itemSize * offset;\n\t\t\tvar length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function normalizeNormals() {\n\n\t\t\tvar normals = this.attributes.normal;\n\n\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t\tvector.x = normals.getX( i );\n\t\t\t\tvector.y = normals.getY( i );\n\t\t\t\tvector.z = normals.getZ( i );\n\n\t\t\t\tvector.normalize();\n\n\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.addAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = this.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar morphArray = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = morphAttribute[ i ];\n\n\t\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\t// groups\n\n\t\tvar groups = this.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\tdata.data.attributes[ key ] = attributeData;\n\n\t\t}\n\n\t\tvar morphAttributes = {};\n\t\tvar hasMorphAttributes = false;\n\n\t\tfor ( var key in this.morphAttributes ) {\n\n\t\t\tvar attributeArray = this.morphAttributes[ key ];\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = attributeArray[ i ];\n\n\t\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\t\tarray.push( attributeData );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) data.data.morphAttributes = morphAttributes;\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar name, i, l;\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = source.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// groups\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nfunction Mesh( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n}\n\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Mesh,\n\n\tisMesh: true,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tvar geometry = this.geometry;\n\t\tvar m, ml, name;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\t\tvar keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\tvar vA = new Vector3();\n\t\tvar vB = new Vector3();\n\t\tvar vC = new Vector3();\n\n\t\tvar tempA = new Vector3();\n\t\tvar tempB = new Vector3();\n\t\tvar tempC = new Vector3();\n\n\t\tvar morphA = new Vector3();\n\t\tvar morphB = new Vector3();\n\t\tvar morphC = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tvar intersectionPoint = new Vector3();\n\t\tvar intersectionPointWorld = new Vector3();\n\n\t\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, uv, a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( position, a );\n\t\t\tvB.fromBufferAttribute( position, b );\n\t\t\tvC.fromBufferAttribute( position, c );\n\n\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( material.morphTargets && morphPosition && morphInfluences ) {\n\n\t\t\t\tmorphA.set( 0, 0, 0 );\n\t\t\t\tmorphB.set( 0, 0, 0 );\n\t\t\t\tmorphC.set( 0, 0, 0 );\n\n\t\t\t\tfor ( var i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar influence = morphInfluences[ i ];\n\t\t\t\t\tvar morphAttribute = morphPosition[ i ];\n\n\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\ttempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t\t\ttempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t\t\ttempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\t\t\tmorphA.addScaledVector( tempA.sub( vA ), influence );\n\t\t\t\t\tmorphB.addScaledVector( tempB.sub( vB ), influence );\n\t\t\t\t\tmorphC.addScaledVector( tempC.sub( vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t\tvA.add( morphA );\n\t\t\t\tvB.add( morphB );\n\t\t\t\tvC.add( morphC );\n\n\t\t\t}\n\n\t\t\tvar intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uv ) {\n\n\t\t\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t\tvar face = new Face3( a, b, c );\n\t\t\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\t\t\tintersection.face = face;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar intersection;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar morphPosition = geometry.morphAttributes.position;\n\t\t\t\tvar uv = geometry.attributes.uv;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar drawRange = geometry.drawRange;\n\t\t\t\tvar i, j, il, jl;\n\t\t\t\tvar group, groupMaterial;\n\t\t\t\tvar start, end;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t// indexed buffer geometry\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );\n\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\t\ta = j;\n\t\t\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );\n\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\t\t\tend = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isMultiMaterial = Array.isArray( material );\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar uvs;\n\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs && uvs[ f ] ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nvar geometryId = 0; // Geometry uses even numbers as Id\n\nfunction Geometry() {\n\n\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj = new Object3D();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( var i = 0; i < positions.length; i += 3 ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromArray( colors, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexColors = ( colors === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone() ];\n\n\t\t\tvar vertexNormals = ( normals === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromArray( normals, a * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, b * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, c * 3 )\n\t\t\t];\n\n\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs2, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tvar offset = new Vector3();\n\n\t\treturn function center() {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tvar f, fl, face;\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar i, il, j, jl, k, kl;\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tvar colors = source.colors;\n\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargets = source.morphTargets;\n\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tvar morphNormals = source.morphNormals;\n\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tvar morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tvar destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tvar skinWeights = source.skinWeights;\n\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tvar skinIndices = source.skinIndices;\n\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tvar lineDistances = source.lineDistances;\n\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// BoxGeometry\n\nfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n}\n\nBoxGeometry.prototype = Object.create( Geometry.prototype );\nBoxGeometry.prototype.constructor = BoxGeometry;\n\n// BoxBufferGeometry\n\nfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\twidth = width || 1;\n\theight = height || 1;\n\tdepth = depth || 1;\n\n\t// segments\n\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar numberOfVertices = 0;\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth = width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar ix, iy;\n\n\t\tvar vector = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t// set values to correct vector component\n\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t// uvs\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t// counters\n\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t// increase counter\n\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n}\n\nBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tvar dst = {};\n\n\tfor ( var u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( var p in src[ u ] ) {\n\n\t\t\tvar property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tvar merged = {};\n\n\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\tvar tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( var p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\n// Legacy\n\nvar UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction ShaderMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = default_vertex;\n\tthis.fragmentShader = default_fragment;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\tthis.uniformsNeedUpdate = false;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nShaderMaterial.prototype = Object.create( Material.prototype );\nShaderMaterial.prototype.constructor = ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\tthis.defines = Object.assign( {}, source.defines );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = {};\n\n\tfor ( var name in this.uniforms ) {\n\n\t\tvar uniform = this.uniforms[ name ];\n\t\tvar value = uniform.value;\n\n\t\tif ( value && value.isTexture ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t};\n\n\t\t} else if ( value && value.isColor ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: value.getHex()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\tvalue: value\n\t\t\t};\n\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t}\n\n\t}\n\n\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\tvar extensions = {};\n\n\tfor ( var key in this.extensions ) {\n\n\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t}\n\n\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\treturn data;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nfunction Camera() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new Matrix4();\n\n\tthis.projectionMatrix = new Matrix4();\n\tthis.projectionMatrixInverse = new Matrix4();\n\n}\n\nCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Camera,\n\n\tisCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\treturn this;\n\n\t},\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Camera: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\tvar e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n}\n\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: PerspectiveCamera,\n\n\tisPerspectiveCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar fov = 90, aspect = 1;\n\nfunction CubeCamera( near, far, cubeResolution, options ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\toptions = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\tthis.renderTarget.texture.name = \"CubeCamera\";\n\n\tthis.update = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0 );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1 );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2 );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3 );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4 );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5 );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\tthis.clear = function ( renderer, color, depth, stencil ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar renderTarget = this.renderTarget;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( renderTarget, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n}\n\nCubeCamera.prototype = Object.create( Object3D.prototype );\nCubeCamera.prototype.constructor = CubeCamera;\n\n/**\n * @author alteredq / http://alteredqualia.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction WebGLRenderTargetCube( width, height, options ) {\n\n\tWebGLRenderTarget.call( this, width, height, options );\n\n}\n\nWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\nWebGLRenderTargetCube.prototype.fromEquirectangularTexture = function ( renderer, texture ) {\n\n\tthis.texture.type = texture.type;\n\tthis.texture.format = texture.format;\n\tthis.texture.encoding = texture.encoding;\n\n\tvar scene = new Scene();\n\n\tvar shader = {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\",\n\n\t\t\t\"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvWorldDirection = transformDirection( position, modelMatrix );\",\n\n\t\t\t\"\t#include <begin_vertex>\",\n\t\t\t\"\t#include <project_vertex>\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tEquirect;\",\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"#define RECIPROCAL_PI 0.31830988618\",\n\t\t\t\"#define RECIPROCAL_PI2 0.15915494\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 direction = normalize( vWorldDirection );\",\n\n\t\t\t\"\tvec2 sampleUV;\",\n\n\t\t\t\"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\",\n\n\t\t\t\"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\n\n\t\t\t\"\tgl_FragColor = texture2D( tEquirect, sampleUV );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\t};\n\n\tvar material = new ShaderMaterial( {\n\n\t\ttype: 'CubemapFromEquirect',\n\n\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tside: BackSide,\n\t\tblending: NoBlending\n\n\t} );\n\n\tmaterial.uniforms.tEquirect.value = texture;\n\n\tvar mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );\n\n\tscene.add( mesh );\n\n\tvar camera = new CubeCamera( 1, 10, 1 );\n\n\tcamera.renderTarget = this;\n\tcamera.renderTarget.texture.name = 'CubeCameraTexture';\n\n\tcamera.update( renderer, scene );\n\n\tmesh.geometry.dispose();\n\tmesh.material.dispose();\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\tthis.generateMipmaps = false;\n\tthis.flipY = false;\n\tthis.unpackAlignment = 1;\n\n}\n\nDataTexture.prototype = Object.create( Texture.prototype );\nDataTexture.prototype.constructor = DataTexture;\n\nDataTexture.prototype.isDataTexture = true;\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Plane( normal, constant ) {\n\n\t// normal is assumed to be normalized\n\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n}\n\nObject.assign( Plane.prototype, {\n\n\tisPlane: true,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function intersectLine( line, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn target.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar m1 = new Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t];\n\n}\n\nObject.assign( Frustum.prototype, {\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p = new Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t// corner at max distance\n\n\t\t\t\tp.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tif ( plane.distanceToPoint( p ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n} );\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = normalMatrix * objectTangent;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar lights_pars_begin = \"uniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\";\n\nvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\t\\tnormal = normalize( vTBN * mapN );\\n\\t\\t#else\\n\\t\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t\\t#endif\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#if defined( DITHERING )\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\";\n\nvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\";\n\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\";\n\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\";\n\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\";\n\nvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar ShaderChunk = {\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tencodings_fragment: encodings_fragment,\n\tencodings_pars_fragment: encodings_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_vertex: lights_lambert_vertex,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tuv2_pars_fragment: uv2_pars_fragment,\n\tuv2_pars_vertex: uv2_pars_vertex,\n\tuv2_vertex: uv2_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_frag: background_frag,\n\tbackground_vert: background_vert,\n\tcube_frag: cube_frag,\n\tcube_vert: cube_vert,\n\tdepth_frag: depth_frag,\n\tdepth_vert: depth_vert,\n\tdistanceRGBA_frag: distanceRGBA_frag,\n\tdistanceRGBA_vert: distanceRGBA_vert,\n\tequirect_frag: equirect_frag,\n\tequirect_vert: equirect_vert,\n\tlinedashed_frag: linedashed_frag,\n\tlinedashed_vert: linedashed_vert,\n\tmeshbasic_frag: meshbasic_frag,\n\tmeshbasic_vert: meshbasic_vert,\n\tmeshlambert_frag: meshlambert_frag,\n\tmeshlambert_vert: meshlambert_vert,\n\tmeshmatcap_frag: meshmatcap_frag,\n\tmeshmatcap_vert: meshmatcap_vert,\n\tmeshphong_frag: meshphong_frag,\n\tmeshphong_vert: meshphong_vert,\n\tmeshphysical_frag: meshphysical_frag,\n\tmeshphysical_vert: meshphysical_vert,\n\tnormal_frag: normal_frag,\n\tnormal_vert: normal_vert,\n\tpoints_frag: points_frag,\n\tpoints_vert: points_vert,\n\tshadow_frag: shadow_frag,\n\tshadow_vert: shadow_vert,\n\tsprite_frag: sprite_frag,\n\tsprite_vert: sprite_vert\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nvar UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() },\n\n\t\talphaMap: { value: null },\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 },\n\t\trefractionRatio: { value: 0.98 },\n\t\tmaxMipLevel: { value: 0 }\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotShadowMap: { value: [] },\n\t\tspotShadowMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nvar ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 0.5 },\n\t\t\t\tmetalness: { value: 0.5 },\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.normal_vert,\n\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearCoat: { value: 0 },\n\t\t\tclearCoatRoughness: { value: 0 }\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLAnimation() {\n\n\tvar context = null;\n\tvar isAnimating = false;\n\tvar animationLoop = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tif ( isAnimating === false ) return;\n\n\t\tanimationLoop( time, frame );\n\n\t\tcontext.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\tcontext.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLAttributes( gl ) {\n\n\tvar buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tvar array = attribute.array;\n\t\tvar usage = attribute.dynamic ? 35048 : 35044;\n\n\t\tvar buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tvar type = 5126;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = 5126;\n\n\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\ttype = 5123;\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = 5122;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = 5125;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = 5124;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = 5120;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = 5121;\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tvar array = attribute.array;\n\t\tvar updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( attribute.dynamic === false ) {\n\n\t\t\tgl.bufferData( bufferType, array, 35044 );\n\n\t\t} else if ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else if ( updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tvar data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tvar data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// PlaneGeometry\n\nfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\tthis.mergeVertices();\n\n}\n\nPlaneGeometry.prototype = Object.create( Geometry.prototype );\nPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n// PlaneBufferGeometry\n\nfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\twidth = width || 1;\n\theight = height || 1;\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar ix, iy;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// generate vertices, normals and uvs\n\n\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\tuvs.push( ix / gridX );\n\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {\n\n\tvar clearColor = new Color( 0x000000 );\n\tvar clearAlpha = 0;\n\n\tvar planeMesh;\n\tvar boxMesh;\n\t// Store the current background texture and its `version`\n\t// so we can recompile the material accordingly.\n\tvar currentBackground = null;\n\tvar currentBackgroundVersion = 0;\n\n\tfunction render( renderList, scene, camera, forceClear ) {\n\n\t\tvar background = scene.background;\n\n\t\t// Ignore background in AR\n\t\t// TODO: Reconsider this.\n\n\t\tvar vr = renderer.vr;\n\t\tvar session = vr.getSession && vr.getSession();\n\n\t\tif ( session && session.environmentBlendMode === 'additive' ) {\n\n\t\t\tbackground = null;\n\n\t\t}\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\t\t\tcurrentBackground = null;\n\t\t\tcurrentBackgroundVersion = 0;\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\t\t\tcurrentBackground = null;\n\t\t\tcurrentBackgroundVersion = 0;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxBufferGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\ttype: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.removeAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.removeAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( boxMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.tCube.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tvar texture = background.isWebGLRenderTargetCube ? background.texture : background;\n\t\t\tboxMesh.material.uniforms.tCube.value = texture;\n\t\t\tboxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t     currentBackgroundVersion !== texture.version ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = texture.version;\n\n\t\t\t}\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\ttype: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.removeAttribute( 'normal' );\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\t   currentBackgroundVersion !== background.version ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\n\t\t\t}\n\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha !== undefined ? alpha : 1;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode );\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension;\n\n\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\textension = gl;\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );\n\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tvar isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n\n\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tvar maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tvar maxTextures = gl.getParameter( 34930 );\n\tvar maxVertexTextures = gl.getParameter( 35660 );\n\tvar maxTextureSize = gl.getParameter( 3379 );\n\tvar maxCubemapSize = gl.getParameter( 34076 );\n\n\tvar maxAttributes = gl.getParameter( 34921 );\n\tvar maxVertexUniforms = gl.getParameter( 36347 );\n\tvar maxVaryings = gl.getParameter( 36348 );\n\tvar maxFragmentUniforms = gl.getParameter( 36349 );\n\n\tvar vertexTextures = maxVertexTextures > 0;\n\tvar floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );\n\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\tvar maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;\n\n\treturn {\n\n\t\tisWebGL2: isWebGL2,\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\tfloatVertexTextures: floatVertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\n/**\n * @author tschw\n */\n\nfunction WebGLClipping() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLExtensions( gl ) {\n\n\tvar extensions = {};\n\n\treturn {\n\n\t\tget: function ( name ) {\n\n\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\treturn extensions[ name ];\n\n\t\t\t}\n\n\t\t\tvar extension;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t}\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\textensions[ name ] = extension;\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLGeometries( gl, attributes, info ) {\n\n\tvar geometries = {};\n\tvar wireframeAttributes = {};\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tattributes.remove( buffergeometry.index );\n\n\t\t}\n\n\t\tfor ( var name in buffergeometry.attributes ) {\n\n\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tvar attribute = wireframeAttributes[ buffergeometry.id ];\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\tdelete wireframeAttributes[ buffergeometry.id ];\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry ) return buffergeometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, 34963 );\n\n\t\t}\n\n\t\tfor ( var name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], 34962 );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\n\t\tif ( attribute ) return attribute;\n\n\t\tvar indices = [];\n\n\t\tvar geometryIndex = geometry.index;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tvar array = geometryIndex.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = geometryAttributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\n\t\tattributes.update( attribute, 34963 );\n\n\t\twireframeAttributes[ geometry.id ] = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode );\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension;\n\n\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\textension = gl;\n\n\t\t} else {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\n\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WebGLInfo( gl ) {\n\n\tvar memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tvar render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\tinstanceCount = instanceCount || 1;\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase 4:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\t\trender.triangles += instanceCount * ( count - 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.frame ++;\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tvar influencesList = {};\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tvar objectInfluences = object.morphTargetInfluences;\n\n\t\tvar length = objectInfluences.length;\n\n\t\tvar influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\t// Remove current morphAttributes\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence[ 1 ] !== 0 ) {\n\n\t\t\t\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\t// Add morphAttributes\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence ) {\n\n\t\t\t\tvar index = influence[ 0 ];\n\t\t\t\tvar value = influence[ 1 ];\n\n\t\t\t\tif ( value ) {\n\n\t\t\t\t\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\t\t\t\t\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t}\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLObjects( geometries, info ) {\n\n\tvar updateList = {};\n\n\tfunction update( object ) {\n\n\t\tvar frame = info.render.frame;\n\n\t\tvar geometry = object.geometry;\n\t\tvar buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateList[ buffergeometry.id ] !== frame ) {\n\n\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\tbuffergeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateList[ buffergeometry.id ] = frame;\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\tformat = format !== undefined ? format : RGBFormat;\n\n\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n}\n\nCubeTexture.prototype = Object.create( Texture.prototype );\nCubeTexture.prototype.constructor = CubeTexture;\n\nCubeTexture.prototype.isCubeTexture = true;\n\nObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n/**\n * @author Takahiro https://github.com/takahirox\n */\n\nfunction DataTexture2DArray( data, width, height, depth ) {\n\n\tTexture.call( this, null );\n\n\tthis.image = { data: data, width: width, height: height, depth: depth };\n\n\tthis.magFilter = NearestFilter;\n\tthis.minFilter = NearestFilter;\n\n\tthis.wrapR = ClampToEdgeWrapping;\n\n\tthis.generateMipmaps = false;\n\tthis.flipY = false;\n\n}\n\nDataTexture2DArray.prototype = Object.create( Texture.prototype );\nDataTexture2DArray.prototype.constructor = DataTexture2DArray;\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\n/**\n * @author Artur Trzesiok\n */\n\nfunction DataTexture3D( data, width, height, depth ) {\n\n\t// We're going to add .setXXX() methods for setting properties later.\n\t// Users can still set in DataTexture3D directly.\n\t//\n\t//\tvar texture = new THREE.DataTexture3D( data, width, height, depth );\n\t// \ttexture.anisotropy = 16;\n\t//\n\t// See #14839\n\n\tTexture.call( this, null );\n\n\tthis.image = { data: data, width: width, height: height, depth: depth };\n\n\tthis.magFilter = NearestFilter;\n\tthis.minFilter = NearestFilter;\n\n\tthis.wrapR = ClampToEdgeWrapping;\n\n\tthis.generateMipmaps = false;\n\tthis.flipY = false;\n\n}\n\nDataTexture3D.prototype = Object.create( Texture.prototype );\nDataTexture3D.prototype.constructor = DataTexture3D;\nDataTexture3D.prototype.isDataTexture3D = true;\n\n/**\n * @author tschw\n * @author Mugen87 / https://github.com/Mugen87\n * @author mrdoob / http://mrdoob.com/\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nvar emptyTexture = new Texture();\nvar emptyTexture2dArray = new DataTexture2DArray();\nvar emptyTexture3d = new DataTexture3D();\nvar emptyCubeTexture = new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nvar arrayCacheF32 = [];\nvar arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nvar mat4array = new Float32Array( 16 );\nvar mat3array = new Float32Array( 9 );\nvar mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tvar firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tvar n = nBlocks * blockSize,\n\t\tr = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( var i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( var i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tvar r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( var i = 0; i !== n; ++ i )\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tvar cache = this.cache;\n\tvar unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTexture2D( v || emptyTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tvar cache = this.cache;\n\tvar unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyTexture2dArray, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tvar cache = this.cache;\n\tvar unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || emptyTexture3d, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tvar cache = this.cache;\n\tvar unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.safeSetTextureCube( v || emptyCubeTexture, unit );\n\n}\n\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\nfunction setValueV1i( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\nfunction setValueV2i( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\n\t\tcase 0x8b5f: return setValueT3D1; // SAMPLER_3D\n\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\tcase 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t}\n\n}\n\n// Array of scalars\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n\n// Array of vectors (flat or from THREE classes)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tvar data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tvar data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tvar data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (flat or from THREE clases)\n\nfunction setValueM2Array( gl, v ) {\n\n\tvar data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tvar data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tvar data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tvar n = v.length;\n\n\tvar units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tvar n = v.length;\n\n\tvar units = allocTexUnits( textures, n );\n\n\tgl.uniform1iv( this.addr, units );\n\n\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\ttextures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x8b5e: return setValueT1Array; // SAMPLER_2D\n\t\tcase 0x8b60: return setValueT6Array; // SAMPLER_CUBE\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.size = activeInfo.size;\n\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nPureArrayUniform.prototype.updateCache = function ( data ) {\n\n\tvar cache = this.cache;\n\n\tif ( data instanceof Float32Array && cache.length !== data.length ) {\n\n\t\tthis.cache = new Float32Array( data.length );\n\n\t}\n\n\tcopyArray( cache, data );\n\n};\n\nfunction StructuredUniform( id ) {\n\n\tthis.id = id;\n\n\tthis.seq = [];\n\tthis.map = {};\n\n}\n\nStructuredUniform.prototype.setValue = function ( gl, value, textures ) {\n\n\tvar seq = this.seq;\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ];\n\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t}\n\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tvar path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tvar match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\tid = match[ 1 ],\n\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tvar map = container.map, next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nfunction WebGLUniforms( gl, program ) {\n\n\tthis.seq = [];\n\tthis.map = {};\n\n\tvar n = gl.getProgramParameter( program, 35718 );\n\n\tfor ( var i = 0; i < n; ++ i ) {\n\n\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\tparseUniform( info, addr, this );\n\n\t}\n\n}\n\nWebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {\n\n\tvar u = this.map[ name ];\n\n\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n};\n\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\n\tvar v = object[ name ];\n\n\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n};\n\n\n// Static interface\n\nWebGLUniforms.upload = function ( gl, seq, values, textures ) {\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ],\n\t\t\tv = values[ u.id ];\n\n\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t}\n\n\t}\n\n};\n\nWebGLUniforms.seqWithValue = function ( seq, values ) {\n\n\tvar r = [];\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ];\n\t\tif ( u.id in values ) r.push( u );\n\n\t}\n\n\treturn r;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLShader( gl, type, string ) {\n\n\tvar shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar programIdCount = 0;\n\nfunction addLineNumbers( string ) {\n\n\tvar lines = string.split( '\\n' );\n\n\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t}\n\n\treturn lines.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( encoding ) {\n\n\tswitch ( encoding ) {\n\n\t\tcase LinearEncoding:\n\t\t\treturn [ 'Linear', '( value )' ];\n\t\tcase sRGBEncoding:\n\t\t\treturn [ 'sRGB', '( value )' ];\n\t\tcase RGBEEncoding:\n\t\t\treturn [ 'RGBE', '( value )' ];\n\t\tcase RGBM7Encoding:\n\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\tcase RGBM16Encoding:\n\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\tcase RGBDEncoding:\n\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\tcase GammaEncoding:\n\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\tdefault:\n\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tvar status = gl.getShaderParameter( shader, 35713 );\n\tvar log = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && log === '' ) return '';\n\n\t// --enable-privileged-webgl-extension\n\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\tvar source = gl.getShaderSource( shader );\n\n\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers( source );\n\n}\n\nfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\tvar components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\n}\n\nfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\tvar components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tvar toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase Uncharted2ToneMapping:\n\t\t\ttoneMappingName = 'Uncharted2';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\textensions = extensions || {};\n\n\tvar chunks = [\n\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tvar chunks = [];\n\n\tfor ( var name in defines ) {\n\n\t\tvar value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tvar attributes = {};\n\n\tvar n = gl.getProgramParameter( program, 35721 );\n\n\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\tvar info = gl.getActiveAttrib( program, i );\n\t\tvar name = info.name;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\nfunction parseIncludes( string ) {\n\n\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n\tfunction replace( match, include ) {\n\n\t\tvar replace = ShaderChunk[ include ];\n\n\t\tif ( replace === undefined ) {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t\treturn parseIncludes( replace );\n\n\t}\n\n\treturn string.replace( pattern, replace );\n\n}\n\nfunction unrollLoops( string ) {\n\n\tvar pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\tfunction replace( match, start, end, snippet ) {\n\n\t\tvar unroll = '';\n\n\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t}\n\n\t\treturn unroll;\n\n\t}\n\n\treturn string.replace( pattern, replace );\n\n}\n\nfunction WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {\n\n\tvar gl = renderer.context;\n\n\tvar defines = material.defines;\n\n\tvar vertexShader = shader.vertexShader;\n\tvar fragmentShader = shader.fragmentShader;\n\n\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t}\n\n\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t\tcase EquirectangularReflectionMapping:\n\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\tbreak;\n\n\t\t\tcase SphericalReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\tcase CubeRefractionMapping:\n\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tswitch ( material.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t// console.log( 'building new program ' );\n\n\t//\n\n\tvar customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );\n\n\tvar customDefines = generateDefines( defines );\n\n\t//\n\n\tvar program = gl.createProgram();\n\n\tvar prefixVertex, prefixFragment;\n\n\tif ( material.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\n\t\t\tparameters.vertexTangents ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\tparameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\n\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?\n\t\t\t\tShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\tparameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',\n\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\n\n\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = parseIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = parseIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {\n\n\t\tvar isGLSL3ShaderMaterial = false;\n\n\t\tvar versionRegex = /^\\s*#version\\s+300\\s+es\\s*\\n/;\n\n\t\tif ( material.isShaderMaterial &&\n\t\t\tvertexShader.match( versionRegex ) !== null &&\n\t\t\tfragmentShader.match( versionRegex ) !== null ) {\n\n\t\t\tisGLSL3ShaderMaterial = true;\n\n\t\t\tvertexShader = vertexShader.replace( versionRegex, '' );\n\t\t\tfragmentShader = fragmentShader.replace( versionRegex, '' );\n\n\t\t}\n\n\t\t// GLSL 3.0 conversion\n\t\tprefixVertex = [\n\t\t\t'#version 300 es\\n',\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#version 300 es\\n',\n\t\t\t'#define varying in',\n\t\t\tisGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',\n\t\t\tisGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tvar vertexGlsl = prefixVertex + vertexShader;\n\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tvar glVertexShader = WebGLShader( gl, 35633, vertexGlsl );\n\tvar glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( material.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\t// check for link errors\n\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\tvar programLog = gl.getProgramInfoLog( program ).trim();\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\tif ( gl.getProgramParameter( program, 35714 ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tvar vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\tvar fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// clean up\n\n\tgl.deleteShader( glVertexShader );\n\tgl.deleteShader( glFragmentShader );\n\n\t// set up caching for uniform locations\n\n\tvar cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tvar cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.name = shader.name;\n\tthis.id = programIdCount ++;\n\tthis.code = code;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLPrograms( renderer, extensions, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"matcap\", \"matcapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"objectSpaceNormalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\", \"gradientMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"vertexTangents\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\n\t];\n\n\n\tfunction allocateBones( object ) {\n\n\t\tvar skeleton = object.skeleton;\n\t\tvar bones = skeleton.bones;\n\n\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = Math.min( nVertexMatrices, bones.length );\n\n\t\t\tif ( maxBones < bones.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t} else if ( map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map.isWebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\n\t\tvar precision = capabilities.precision;\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tmatcap: !! material.matcap,\n\t\t\tmatcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tgradientMap: !! material.gradientMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexTangents: ( material.normalMap && material.vertexTangents ),\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: ( fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning && maxBones > 0,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\tarray.push( material.onBeforeCompile.toString() );\n\n\t\tarray.push( renderer.gammaOutput );\n\n\t\tarray.push( renderer.gammaFactor );\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, shader, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function ( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n}\n\n/**\n * @author fordacious / fordacious.github.io\n */\n\nfunction WebGLProperties() {\n\n\tvar properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tvar map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.program !== b.program ) {\n\n\t\treturn a.program.id - b.program.id;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tvar renderItems = [];\n\tvar renderItemsIndex = 0;\n\n\tvar opaque = [];\n\tvar transparent = [];\n\n\tvar defaultProgram = { id: - 1 };\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tprogram: material.program || defaultProgram,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.program = material.program || defaultProgram;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).unshift( renderItem );\n\n\t}\n\n\tfunction sort() {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\n\n\t}\n\n\treturn {\n\t\topaque: opaque,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tvar lists = {};\n\n\tfunction onSceneDispose( event ) {\n\n\t\tvar scene = event.target;\n\n\t\tscene.removeEventListener( 'dispose', onSceneDispose );\n\n\t\tdelete lists[ scene.id ];\n\n\t}\n\n\tfunction get( scene, camera ) {\n\n\t\tvar cameras = lists[ scene.id ];\n\t\tvar list;\n\t\tif ( cameras === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists[ scene.id ] = {};\n\t\t\tlists[ scene.id ][ camera.id ] = list;\n\n\t\t\tscene.addEventListener( 'dispose', onSceneDispose );\n\n\t\t} else {\n\n\t\t\tlist = cameras[ camera.id ];\n\t\t\tif ( list === undefined ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tcameras[ camera.id ] = list;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = {};\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction UniformsCache() {\n\n\tvar lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tvar uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nvar nextVersion = 0;\n\nfunction WebGLLights() {\n\n\tvar cache = new UniformsCache();\n\n\tvar state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\t\t\tshadowsLength: - 1,\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\trectArea: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: []\n\n\t};\n\n\tfor ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tvar vector3 = new Vector3();\n\tvar matrix4 = new Matrix4();\n\tvar matrix42 = new Matrix4();\n\n\tfunction setup( lights, shadows, camera ) {\n\n\t\tvar r = 0, g = 0, b = 0;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tvar directionalLength = 0;\n\t\tvar pointLength = 0;\n\t\tvar spotLength = 0;\n\t\tvar rectAreaLength = 0;\n\t\tvar hemiLength = 0;\n\n\t\tvar viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tvar color = light.color;\n\t\t\tvar intensity = light.intensity;\n\t\t\tvar distance = light.distance;\n\n\t\t\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( var j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\t// TODO (abelnation): RectAreaLight distance?\n\t\t\t\t// uniforms.distance = distance;\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tuniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tuniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t}\n\n\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tvar hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.shadowsLength !== shadows.length ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\t\t\thash.shadowsLength = shadows.length;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tstate: state\n\t};\n\n}\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WebGLRenderState() {\n\n\tvar lights = new WebGLLights();\n\n\tvar lightsArray = [];\n\tvar shadowsArray = [];\n\n\tfunction init() {\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights( camera ) {\n\n\t\tlights.setup( lightsArray, shadowsArray, camera );\n\n\t}\n\n\tvar state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tlights: lights\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates() {\n\n\tvar renderStates = {};\n\n\tfunction onSceneDispose( event ) {\n\n\t\tvar scene = event.target;\n\n\t\tscene.removeEventListener( 'dispose', onSceneDispose );\n\n\t\tdelete renderStates[ scene.id ];\n\n\t}\n\n\tfunction get( scene, camera ) {\n\n\t\tvar renderState;\n\n\t\tif ( renderStates[ scene.id ] === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState();\n\t\t\trenderStates[ scene.id ] = {};\n\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\n\n\t\t\tscene.addEventListener( 'dispose', onSceneDispose );\n\n\t\t} else {\n\n\t\t\tif ( renderStates[ scene.id ][ camera.id ] === undefined ) {\n\n\t\t\t\trenderState = new WebGLRenderState();\n\t\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStates[ scene.id ][ camera.id ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = {};\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nfunction MeshDepthMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshDepthMaterial.prototype = Object.create( Material.prototype );\nMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\nMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nfunction MeshDistanceMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshDistanceMaterial';\n\n\tthis.referencePosition = new Vector3();\n\tthis.nearDistance = 1;\n\tthis.farDistance = 1000;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshDistanceMaterial.prototype = Object.create( Material.prototype );\nMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\nMeshDistanceMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.referencePosition.copy( source.referencePosition );\n\tthis.nearDistance = source.nearDistance;\n\tthis.farDistance = source.farDistance;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\n\n\tvar _frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tvar cubeDirections = [\n\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\tnew Vector4(), new Vector4(), new Vector4()\n\t];\n\n\t// init\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = new MeshDepthMaterial( {\n\n\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning\n\n\t\t} );\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t//\n\n\t\tvar distanceMaterial = new MeshDistanceMaterial( {\n\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning\n\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tvar currentRenderTarget = _renderer.getRenderTarget();\n\t\tvar activeCubeFace = _renderer.getActiveCubeFace();\n\t\tvar activeMipMapLevel = _renderer.getActiveMipMapLevel();\n\n\t\tvar _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount;\n\n\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\t\t\tvar shadow = light.shadow;\n\t\t\tvar isPointLight = light && light.isPointLight;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow.isSpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\n\t\t\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\n\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t}\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\trenderObject( scene, camera, shadowCamera, isPointLight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipMapLevel );\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = false;\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tif ( geometry && geometry.isBufferGeometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t} else if ( geometry && geometry.isGeometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh && material.skinning === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\n\t\t\t}\n\n\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tresult.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.isMeshDistanceMaterial ) {\n\n\t\t\tresult.referencePosition.copy( lightPositionWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tvar visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLState( gl, extensions, utils, capabilities ) {\n\n\tfunction ColorBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar color = new Vector4();\n\t\tvar currentColorMask = null;\n\t\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar currentDepthMask = null;\n\t\tvar currentDepthFunc = null;\n\t\tvar currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( 2929 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2929 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 512 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 519 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 513 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 514 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 518 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 516 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 517 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar currentStencilMask = null;\n\t\tvar currentStencilFunc = null;\n\t\tvar currentStencilRef = null;\n\t\tvar currentStencilFuncMask = null;\n\t\tvar currentStencilFail = null;\n\t\tvar currentStencilZFail = null;\n\t\tvar currentStencilZPass = null;\n\t\tvar currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\tenable( 2960 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2960 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tvar colorBuffer = new ColorBuffer();\n\tvar depthBuffer = new DepthBuffer();\n\tvar stencilBuffer = new StencilBuffer();\n\n\tvar maxVertexAttributes = gl.getParameter( 34921 );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar enabledCapabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentProgram = null;\n\n\tvar currentBlendingEnabled = null;\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar maxTextures = gl.getParameter( 35661 );\n\n\tvar lineWidthAvailable = false;\n\tvar version = 0;\n\tvar glVersion = gl.getParameter( 7938 );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new Vector4();\n\tvar currentViewport = new Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, 10241, 9728 );\n\t\tgl.texParameteri( type, 10240, 9728 );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );\n\temptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( 2929 );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( 2884 );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction initAttributes() {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tvar extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction getCompressedTextureFormats() {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( 34467 );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled ) {\n\n\t\t\t\tdisable( 3042 );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( ! currentBlendingEnabled ) {\n\n\t\t\tenable( 3042 );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( 32774 );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 1, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 0, 769, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 768, 0, 770 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 770, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 770, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 769 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 768 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = null;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( 2884 )\n\t\t\t: enable( 2884 );\n\n\t\tvar flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( 2304 );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( 2305 );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( 2884 );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( 1029 );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( 1028 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( 1032 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 2884 );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( 32823 );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 32823 );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( 3089 );\n\n\t\t} else {\n\n\t\t\tdisable( 3089 );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\tactiveTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tenabledCapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\tenable: enable,\n\t\tdisable: disable,\n\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tvar _videoTextures = {};\n\tvar _canvas;\n\n\t//\n\n\tvar useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\tnew OffscreenCanvas( width, height ) :\n\t\t\tdocument.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\n\n\t\tvar scale = 1;\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( image.width, image.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 || needsPowerOfTwo === true ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tvar floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;\n\n\t\t\t\tvar width = floor( scale * image.width );\n\t\t\t\tvar height = floor( scale * image.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tvar canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( capabilities.isWebGL2 ) return false;\n\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\n\n\t\treturn texture.generateMipmaps && supportsMips &&\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target, texture, width, height ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\t// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11\n\t\ttextureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;\n\n\t}\n\n\tfunction getInternalFormat( glFormat, glType ) {\n\n\t\tif ( ! capabilities.isWebGL2 ) return glFormat;\n\n\t\tvar internalFormat = glFormat;\n\n\t\tif ( glFormat === 6403 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 33326;\n\t\t\tif ( glType === 5131 ) internalFormat = 33325;\n\t\t\tif ( glType === 5121 ) internalFormat = 33321;\n\n\t\t}\n\n\t\tif ( glFormat === 6407 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34837;\n\t\t\tif ( glType === 5131 ) internalFormat = 34843;\n\t\t\tif ( glType === 5121 ) internalFormat = 32849;\n\n\t\t}\n\n\t\tif ( glFormat === 6408 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34836;\n\t\t\tif ( glType === 5131 ) internalFormat = 34842;\n\t\t\tif ( glType === 5121 ) internalFormat = 32856;\n\n\t\t}\n\n\t\tif ( internalFormat === 33325 || internalFormat === 33326 ||\n\t\t\tinternalFormat === 34842 || internalFormat === 34836 ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t} else if ( internalFormat === 34843 || internalFormat === 34837 ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback( f ) {\n\n\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\treturn 9728;\n\n\t\t}\n\n\t\treturn 9729;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tdelete _videoTextures[ texture.id ];\n\n\t\t}\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.remove( renderTarget.texture );\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tvar textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tvar textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 35866, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 32879, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tinitTexture( textureProperties, texture );\n\n\t\t\t\tstate.activeTexture( 33984 + slot );\n\t\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t\t\t\t_gl.pixelStorei( 37440, texture.flipY );\n\n\t\t\t\tvar isCompressed = ( texture && texture.isCompressedTexture );\n\t\t\t\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tsupportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,\n\t\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\t\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\t\tgenerateMipmap( 34067, texture, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( 33984 + slot );\n\t\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters( textureType, texture, supportsMips ) {\n\n\t\tvar extension;\n\n\t\tif ( supportsMips ) {\n\n\t\t\t_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, 10242, 33071 );\n\t\t\t_gl.texParameteri( textureType, 10243, 33071 );\n\n\t\t\tif ( textureType === 32879 || textureType === 35866 ) {\n\n\t\t\t\t_gl.texParameteri( textureType, 32882, 33071 );\n\n\t\t\t}\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tvar textureType = 3553;\n\n\t\tif ( texture.isDataTexture2DArray ) textureType = 35866;\n\t\tif ( texture.isDataTexture3D ) textureType = 32879;\n\n\t\tinitTexture( textureProperties, texture );\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\n\t\tvar needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;\n\t\tvar image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );\n\n\t\tvar supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\tglType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\tsetTextureParameters( textureType, texture, supportsMips );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tglInternalFormat = 6402;\n\n\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\tif ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\n\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t} else if ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tglInternalFormat = 33189;\n\n\t\t\t}\n\n\t\t\tif ( texture.format === DepthFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\tglInternalFormat = 34041;\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else if ( texture.isDataTexture2DArray ) {\n\n\t\t\tstate.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else if ( texture.isDataTexture3D ) {\n\n\t\t\tstate.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tgenerateMipmap( 3553, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\t\t_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( 36161, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );\n\n\t\t} else {\n\n\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\tinfo.memory.textures ++;\n\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\t\tvar isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );\n\t\tvar supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\t\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\t\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, null );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 34067, renderTarget.texture, supportsMips );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 34067, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 3553, renderTarget.texture, supportsMips );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 3553, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\t\tvar supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tvar target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\t_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tvar width = renderTarget.width;\n\t\t\t\tvar height = renderTarget.height;\n\t\t\t\tvar mask = 16384;\n\n\t\t\t\tif ( renderTarget.depthBuffer ) mask |= 256;\n\t\t\t\tif ( renderTarget.stencilBuffer ) mask |= 1024;\n\n\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?\n\t\t\tMath.min( capabilities.maxSamples, renderTarget.samples ) : 0;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tvar id = texture.id;\n\t\tvar frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures[ id ] !== frame ) {\n\n\t\t\t_videoTextures[ id ] = frame;\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\t// backwards compatibility\n\n\tvar warnedTexture2D = false;\n\tvar warnedTextureCube = false;\n\n\tfunction safeSetTexture2D( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\tif ( warnedTexture2D === false ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\twarnedTexture2D = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\t\tsetTexture2D( texture, slot );\n\n\t}\n\n\tfunction safeSetTextureCube( texture, slot ) {\n\n\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\tif ( warnedTextureCube === false ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\twarnedTextureCube = true;\n\n\t\t\t}\n\n\t\t\ttexture = texture.texture;\n\n\t\t}\n\n\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t// TODO: unify these code paths\n\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t// this function alone should take care of cube textures\n\t\t\tsetTextureCube( texture, slot );\n\n\t\t} else {\n\n\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\t\tsetTextureCubeDynamic( texture, slot );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\n\tthis.safeSetTexture2D = safeSetTexture2D;\n\tthis.safeSetTextureCube = safeSetTextureCube;\n\n}\n\n/**\n * @author thespite / http://www.twitter.com/thespite\n */\n\nfunction WebGLUtils( gl, extensions, capabilities ) {\n\n\tfunction convert( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === RepeatWrapping ) return 10497;\n\t\tif ( p === ClampToEdgeWrapping ) return 33071;\n\t\tif ( p === MirroredRepeatWrapping ) return 33648;\n\n\t\tif ( p === NearestFilter ) return 9728;\n\t\tif ( p === NearestMipMapNearestFilter ) return 9984;\n\t\tif ( p === NearestMipMapLinearFilter ) return 9986;\n\n\t\tif ( p === LinearFilter ) return 9729;\n\t\tif ( p === LinearMipMapNearestFilter ) return 9985;\n\t\tif ( p === LinearMipMapLinearFilter ) return 9987;\n\n\t\tif ( p === UnsignedByteType ) return 5121;\n\t\tif ( p === UnsignedShort4444Type ) return 32819;\n\t\tif ( p === UnsignedShort5551Type ) return 32820;\n\t\tif ( p === UnsignedShort565Type ) return 33635;\n\n\t\tif ( p === ByteType ) return 5120;\n\t\tif ( p === ShortType ) return 5122;\n\t\tif ( p === UnsignedShortType ) return 5123;\n\t\tif ( p === IntType ) return 5124;\n\t\tif ( p === UnsignedIntType ) return 5125;\n\t\tif ( p === FloatType ) return 5126;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) return 5131;\n\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return 6406;\n\t\tif ( p === RGBFormat ) return 6407;\n\t\tif ( p === RGBAFormat ) return 6408;\n\t\tif ( p === LuminanceFormat ) return 6409;\n\t\tif ( p === LuminanceAlphaFormat ) return 6410;\n\t\tif ( p === DepthFormat ) return 6402;\n\t\tif ( p === DepthStencilFormat ) return 34041;\n\t\tif ( p === RedFormat ) return 6403;\n\n\t\tif ( p === AddEquation ) return 32774;\n\t\tif ( p === SubtractEquation ) return 32778;\n\t\tif ( p === ReverseSubtractEquation ) return 32779;\n\n\t\tif ( p === ZeroFactor ) return 0;\n\t\tif ( p === OneFactor ) return 1;\n\t\tif ( p === SrcColorFactor ) return 768;\n\t\tif ( p === OneMinusSrcColorFactor ) return 769;\n\t\tif ( p === SrcAlphaFactor ) return 770;\n\t\tif ( p === OneMinusSrcAlphaFactor ) return 771;\n\t\tif ( p === DstAlphaFactor ) return 772;\n\t\tif ( p === OneMinusDstAlphaFactor ) return 773;\n\n\t\tif ( p === DstColorFactor ) return 774;\n\t\tif ( p === OneMinusDstColorFactor ) return 775;\n\t\tif ( p === SrcAlphaSaturateFactor ) return 776;\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tif ( p === MinEquation ) return 32775;\n\t\t\t\tif ( p === MaxEquation ) return 32776;\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) return 34042;\n\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Group() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Group';\n\n}\n\nGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Group,\n\n\tisGroup: true\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction ArrayCamera( array ) {\n\n\tPerspectiveCamera.call( this );\n\n\tthis.cameras = array || [];\n\n}\n\nArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\n\n\tconstructor: ArrayCamera,\n\n\tisArrayCamera: true\n\n} );\n\n/**\n * @author jsantell / https://www.jsantell.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar cameraLPos = new Vector3();\nvar cameraRPos = new Vector3();\n\n/**\n * Assumes 2 cameras that are parallel and share an X-axis, and that\n * the cameras' projection and world matrices have already been set.\n * And that near and far planes are identical for both cameras.\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n */\nfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\tvar ipd = cameraLPos.distanceTo( cameraRPos );\n\n\tvar projL = cameraL.projectionMatrix.elements;\n\tvar projR = cameraR.projectionMatrix.elements;\n\n\t// VR systems will have identical far and near planes, and\n\t// most likely identical top and bottom frustum extents.\n\t// Use the left camera for these values.\n\tvar near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\tvar far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\tvar topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\tvar bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\tvar leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\tvar rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\tvar left = near * leftFov;\n\tvar right = near * rightFov;\n\n\t// Calculate the new camera's position offset from the\n\t// left camera. xOffset should be roughly half `ipd`.\n\tvar zOffset = ipd / ( - leftFov + rightFov );\n\tvar xOffset = zOffset * - leftFov;\n\n\t// TODO: Better way to apply this offset?\n\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.translateX( xOffset );\n\tcamera.translateZ( zOffset );\n\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t// Find the union of the frustum values of the cameras and scale\n\t// the values so that the near plane's position does not change in world space,\n\t// although must now be relative to the new union camera.\n\tvar near2 = near + zOffset;\n\tvar far2 = far + zOffset;\n\tvar left2 = left - xOffset;\n\tvar right2 = right + ( ipd - xOffset );\n\tvar top2 = topFov * far / far2 * near2;\n\tvar bottom2 = bottomFov * far / far2 * near2;\n\n\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebVRManager( renderer ) {\n\n\tvar renderWidth, renderHeight;\n\tvar scope = this;\n\n\tvar device = null;\n\tvar frameData = null;\n\n\tvar poseTarget = null;\n\n\tvar controllers = [];\n\tvar standingMatrix = new Matrix4();\n\tvar standingMatrixInverse = new Matrix4();\n\n\tvar framebufferScaleFactor = 1.0;\n\n\tvar referenceSpaceType = 'local-floor';\n\n\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\n\n\t\tframeData = new window.VRFrameData();\n\t\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\n\t}\n\n\tvar matrixWorldInverse = new Matrix4();\n\tvar tempQuaternion = new Quaternion();\n\tvar tempPosition = new Vector3();\n\n\tvar cameraL = new PerspectiveCamera();\n\tcameraL.viewport = new Vector4();\n\tcameraL.layers.enable( 1 );\n\n\tvar cameraR = new PerspectiveCamera();\n\tcameraR.viewport = new Vector4();\n\tcameraR.layers.enable( 2 );\n\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\tcameraVR.layers.enable( 1 );\n\tcameraVR.layers.enable( 2 );\n\n\t//\n\n\tfunction isPresenting() {\n\n\t\treturn device !== null && device.isPresenting === true;\n\n\t}\n\n\tvar currentSize = new Vector2(), currentPixelRatio;\n\n\tfunction onVRDisplayPresentChange() {\n\n\t\tif ( isPresenting() ) {\n\n\t\t\tvar eyeParameters = device.getEyeParameters( 'left' );\n\t\t\trenderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor;\n\t\t\trenderHeight = eyeParameters.renderHeight * framebufferScaleFactor;\n\n\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\trenderer.getSize( currentSize );\n\n\t\t\trenderer.setDrawingBufferSize( renderWidth, renderHeight, 1 );\n\n\t\t\tcameraL.viewport.set( 0, 0, renderWidth / 2, renderHeight );\n\t\t\tcameraR.viewport.set( renderWidth / 2, 0, renderWidth / 2, renderHeight );\n\n\t\t\tanimation.start();\n\n\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t} else {\n\n\t\t\tif ( scope.enabled ) {\n\n\t\t\t\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\n\n\t\t\t}\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tvar triggers = [];\n\n\tfunction findGamepad( id ) {\n\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\n\n\t\tfor ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {\n\n\t\t\tvar gamepad = gamepads[ i ];\n\n\t\t\tif ( gamepad && ( gamepad.id === 'Daydream Controller' ||\n\t\t\t\tgamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||\n\t\t\t\tgamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||\n\t\t\t\tgamepad.id.startsWith( 'HTC Vive Focus' ) ||\n\t\t\t\tgamepad.id.startsWith( 'Spatial Controller' ) ) ) {\n\n\t\t\t\tif ( j === id ) return gamepad;\n\n\t\t\t\tj ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateControllers() {\n\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tvar controller = controllers[ i ];\n\n\t\t\tvar gamepad = findGamepad( i );\n\n\t\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\n\n\t\t\t\tif ( gamepad.pose === null ) return;\n\n\t\t\t\t// Pose\n\n\t\t\t\tvar pose = gamepad.pose;\n\n\t\t\t\tif ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );\n\n\t\t\t\tif ( pose.position !== null ) controller.position.fromArray( pose.position );\n\t\t\t\tif ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );\n\t\t\t\tcontroller.matrix.compose( controller.position, controller.quaternion, controller.scale );\n\t\t\t\tcontroller.matrix.premultiply( standingMatrix );\n\t\t\t\tcontroller.matrix.decompose( controller.position, controller.quaternion, controller.scale );\n\t\t\t\tcontroller.matrixWorldNeedsUpdate = true;\n\t\t\t\tcontroller.visible = true;\n\n\t\t\t\t// Trigger\n\n\t\t\t\tvar buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;\n\n\t\t\t\tif ( triggers[ i ] === undefined ) triggers[ i ] = false;\n\n\t\t\t\tif ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {\n\n\t\t\t\t\ttriggers[ i ] = gamepad.buttons[ buttonId ].pressed;\n\n\t\t\t\t\tif ( triggers[ i ] === true ) {\n\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectstart' } );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectend' } );\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'select' } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcontroller.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateViewportFromBounds( viewport, bounds ) {\n\n\t\tif ( bounds !== null && bounds.length === 4 ) {\n\n\t\t\tviewport.set( bounds[ 0 ] * renderWidth, bounds[ 1 ] * renderHeight, bounds[ 2 ] * renderWidth, bounds[ 3 ] * renderHeight );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.enabled = false;\n\n\tthis.getController = function ( id ) {\n\n\t\tvar controller = controllers[ id ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new Group();\n\t\t\tcontroller.matrixAutoUpdate = false;\n\t\t\tcontroller.visible = false;\n\n\t\t\tcontrollers[ id ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t};\n\n\tthis.getDevice = function () {\n\n\t\treturn device;\n\n\t};\n\n\tthis.setDevice = function ( value ) {\n\n\t\tif ( value !== undefined ) device = value;\n\n\t\tanimation.setContext( value );\n\n\t};\n\n\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\tframebufferScaleFactor = value;\n\n\t};\n\n\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\treferenceSpaceType = value;\n\n\t};\n\n\tthis.setPoseTarget = function ( object ) {\n\n\t\tif ( object !== undefined ) poseTarget = object;\n\n\t};\n\n\tthis.getCamera = function ( camera ) {\n\n\t\tvar userHeight = referenceSpaceType === 'local-floor' ? 1.6 : 0;\n\n\t\tif ( isPresenting() === false ) {\n\n\t\t\tcamera.position.set( 0, userHeight, 0 );\n\t\t\tcamera.rotation.set( 0, 0, 0 );\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tdevice.depthNear = camera.near;\n\t\tdevice.depthFar = camera.far;\n\n\t\tdevice.getFrameData( frameData );\n\n\t\t//\n\n\t\tif ( referenceSpaceType === 'local-floor' ) {\n\n\t\t\tvar stageParameters = device.stageParameters;\n\n\t\t\tif ( stageParameters ) {\n\n\t\t\t\tstandingMatrix.fromArray( stageParameters.sittingToStandingTransform );\n\n\t\t\t} else {\n\n\t\t\t\tstandingMatrix.makeTranslation( 0, userHeight, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar pose = frameData.pose;\n\t\tvar poseObject = poseTarget !== null ? poseTarget : camera;\n\n\t\t// We want to manipulate poseObject by its position and quaternion components since users may rely on them.\n\t\tposeObject.matrix.copy( standingMatrix );\n\t\tposeObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );\n\n\t\tif ( pose.orientation !== null ) {\n\n\t\t\ttempQuaternion.fromArray( pose.orientation );\n\t\t\tposeObject.quaternion.multiply( tempQuaternion );\n\n\t\t}\n\n\t\tif ( pose.position !== null ) {\n\n\t\t\ttempQuaternion.setFromRotationMatrix( standingMatrix );\n\t\t\ttempPosition.fromArray( pose.position );\n\t\t\ttempPosition.applyQuaternion( tempQuaternion );\n\t\t\tposeObject.position.add( tempPosition );\n\n\t\t}\n\n\t\tposeObject.updateMatrixWorld();\n\n\t\t//\n\n\t\tcameraL.near = camera.near;\n\t\tcameraR.near = camera.near;\n\n\t\tcameraL.far = camera.far;\n\t\tcameraR.far = camera.far;\n\n\t\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\n\t\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\n\n\t\t// TODO (mrdoob) Double check this code\n\n\t\tstandingMatrixInverse.getInverse( standingMatrix );\n\n\t\tif ( referenceSpaceType === 'local-floor' ) {\n\n\t\t\tcameraL.matrixWorldInverse.multiply( standingMatrixInverse );\n\t\t\tcameraR.matrixWorldInverse.multiply( standingMatrixInverse );\n\n\t\t}\n\n\t\tvar parent = poseObject.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\n\t\t\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\n\t\t\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\n\n\t\t}\n\n\t\t// envMap and Mirror needs camera.matrixWorld\n\n\t\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\n\t\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\n\n\t\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\n\t\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\n\n\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t//\n\n\t\tvar layers = device.getLayers();\n\n\t\tif ( layers.length ) {\n\n\t\t\tvar layer = layers[ 0 ];\n\n\t\t\tupdateViewportFromBounds( cameraL.viewport, layer.leftBounds );\n\t\t\tupdateViewportFromBounds( cameraR.viewport, layer.rightBounds );\n\n\t\t}\n\n\t\tupdateControllers();\n\n\t\treturn cameraVR;\n\n\t};\n\n\tthis.getStandingMatrix = function () {\n\n\t\treturn standingMatrix;\n\n\t};\n\n\tthis.isPresenting = isPresenting;\n\n\t// Animation Loop\n\n\tvar animation = new WebGLAnimation();\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tanimation.setAnimationLoop( callback );\n\n\t\tif ( isPresenting() ) animation.start();\n\n\t};\n\n\tthis.submitFrame = function () {\n\n\t\tif ( isPresenting() ) device.submitFrame();\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tif ( typeof window !== 'undefined' ) {\n\n\t\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\n\n\t\t}\n\n\t};\n\n\t// DEPRECATED\n\n\tthis.setFrameOfReferenceType = function () {\n\n\t\tconsole.warn( 'THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.' );\n\n\t};\n\n}\n\nObject.assign( WebVRManager.prototype, EventDispatcher.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebXRManager( renderer ) {\n\n\tvar scope = this;\n\n\tvar gl = renderer.context;\n\n\tvar session = null;\n\n\tvar referenceSpace = null;\n\tvar referenceSpaceType = 'local-floor';\n\n\tvar pose = null;\n\n\tvar controllers = [];\n\tvar inputSources = [];\n\n\tfunction isPresenting() {\n\n\t\treturn session !== null && referenceSpace !== null;\n\n\t}\n\n\t//\n\n\tvar cameraL = new PerspectiveCamera();\n\tcameraL.layers.enable( 1 );\n\tcameraL.viewport = new Vector4();\n\n\tvar cameraR = new PerspectiveCamera();\n\tcameraR.layers.enable( 2 );\n\tcameraR.viewport = new Vector4();\n\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\tcameraVR.layers.enable( 1 );\n\tcameraVR.layers.enable( 2 );\n\n\t//\n\n\tthis.enabled = false;\n\n\tthis.getController = function ( id ) {\n\n\t\tvar controller = controllers[ id ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new Group();\n\t\t\tcontroller.matrixAutoUpdate = false;\n\t\t\tcontroller.visible = false;\n\n\t\t\tcontrollers[ id ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t};\n\n\t//\n\n\tfunction onSessionEvent( event ) {\n\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tif ( inputSources[ i ] === event.inputSource ) {\n\n\t\t\t\tcontrollers[ i ].dispatchEvent( { type: event.type } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction onSessionEnd() {\n\n\t\trenderer.setFramebuffer( null );\n\t\trenderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830\n\t\tanimation.stop();\n\n\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t}\n\n\tfunction onRequestReferenceSpace( value ) {\n\n\t\treferenceSpace = value;\n\n\t\tanimation.setContext( session );\n\t\tanimation.start();\n\n\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t}\n\n\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t};\n\n\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\treferenceSpaceType = value;\n\n\t};\n\n\tthis.getSession = function () {\n\n\t\treturn session;\n\n\t};\n\n\tthis.setSession = function ( value ) {\n\n\t\tsession = value;\n\n\t\tif ( session !== null ) {\n\n\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\n\t\t\tsession.updateRenderState( { baseLayer: new XRWebGLLayer( session, gl ) } );\n\n\t\t\tsession.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );\n\n\t\t\t//\n\n\t\t\tinputSources = session.inputSources;\n\n\t\t\tsession.addEventListener( 'inputsourceschange', function () {\n\n\t\t\t\tinputSources = session.inputSources;\n\t\t\t\tconsole.log( inputSources );\n\n\t\t\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\tvar controller = controllers[ i ];\n\t\t\t\t\tcontroller.userData.inputSource = inputSources[ i ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tfunction updateCamera( camera, parent ) {\n\n\t\tif ( parent === null ) {\n\n\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t} else {\n\n\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t}\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t}\n\n\tthis.getCamera = function ( camera ) {\n\n\t\tif ( isPresenting() ) {\n\n\t\t\tvar parent = camera.parent;\n\t\t\tvar cameras = cameraVR.cameras;\n\n\t\t\tupdateCamera( cameraVR, parent );\n\n\t\t\tfor ( var i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update camera and its children\n\n\t\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\n\n\t\t\tvar children = camera.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t\treturn cameraVR;\n\n\t\t}\n\n\t\treturn camera;\n\n\t};\n\n\tthis.isPresenting = isPresenting;\n\n\t// Animation Loop\n\n\tvar onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tpose = frame.getViewerPose( referenceSpace );\n\n\t\tif ( pose !== null ) {\n\n\t\t\tvar views = pose.views;\n\t\t\tvar baseLayer = session.renderState.baseLayer;\n\n\t\t\trenderer.setFramebuffer( baseLayer.framebuffer );\n\n\t\t\tfor ( var i = 0; i < views.length; i ++ ) {\n\n\t\t\t\tvar view = views[ i ];\n\t\t\t\tvar viewport = baseLayer.getViewport( view );\n\t\t\t\tvar viewMatrix = view.transform.inverse.matrix;\n\n\t\t\t\tvar camera = cameraVR.cameras[ i ];\n\t\t\t\tcamera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );\n\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tvar controller = controllers[ i ];\n\n\t\t\tvar inputSource = inputSources[ i ];\n\n\t\t\tif ( inputSource ) {\n\n\t\t\t\tvar inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\tcontroller.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\tcontroller.matrix.decompose( controller.position, controller.rotation, controller.scale );\n\t\t\t\t\tcontroller.visible = true;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcontroller.visible = false;\n\n\t\t}\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tvar animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\n\t};\n\n\tthis.dispose = function () {};\n\n\t// DEPRECATED\n\n\tthis.getStandingMatrix = function () {\n\n\t\tconsole.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );\n\t\treturn new Matrix4();\n\n\t};\n\n\tthis.getDevice = function () {\n\n\t\tconsole.warn( 'THREE.WebXRManager: getDevice() has been deprecated.' );\n\n\t};\n\n\tthis.setDevice = function () {\n\n\t\tconsole.warn( 'THREE.WebXRManager: setDevice() has been deprecated.' );\n\n\t};\n\n\tthis.setFrameOfReferenceType = function () {\n\n\t\tconsole.warn( 'THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.' );\n\n\t};\n\n\tthis.submitFrame = function () {};\n\n}\n\nObject.assign( WebXRManager.prototype, EventDispatcher.prototype );\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nfunction WebGLRenderer( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\tvar currentRenderList = null;\n\tvar currentRenderState = null;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// Debug configuration container\n\tthis.debug = {\n\n\t\t/**\n\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t * @type {boolean}\n\t\t */\n\t\tcheckShaderErrors: true\n\t};\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t\t_isContextLost = false,\n\n\t\t// internal state cache\n\n\t\t_framebuffer = null,\n\n\t\t_currentActiveCubeFace = 0,\n\t\t_currentActiveMipmapLevel = 0,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\n\t\t// geometry and program caching\n\n\t\t_currentGeometryProgram = {\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false\n\t\t},\n\n\t\t_currentCamera = null,\n\t\t_currentArrayCamera = null,\n\n\t\t_currentViewport = new Vector4(),\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t//\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3();\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar contextAttributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\tpowerPreference: _powerPreference,\n\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,\n\t\t\txrCompatible: true\n\t\t};\n\n\t\t// event listeners must be registered before WebGL context is created, see #12753\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\tthrow error;\n\n\t}\n\n\tvar extensions, capabilities, state, info;\n\tvar properties, textures, attributes, geometries, objects;\n\tvar programCache, renderLists, renderStates;\n\n\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\tvar utils;\n\n\tfunction initGLContext() {\n\n\t\textensions = new WebGLExtensions( _gl );\n\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tif ( ! capabilities.isWebGL2 ) {\n\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'OES_element_index_uint' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t}\n\n\t\textensions.get( 'OES_texture_float_linear' );\n\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\tstate = new WebGLState( _gl, extensions, utils, capabilities );\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t\tinfo = new WebGLInfo( _gl );\n\t\tproperties = new WebGLProperties();\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\tattributes = new WebGLAttributes( _gl );\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info );\n\t\tobjects = new WebGLObjects( geometries, info );\n\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\n\t\trenderLists = new WebGLRenderLists();\n\t\trenderStates = new WebGLRenderStates();\n\n\t\tbackground = new WebGLBackground( _this, state, objects, _premultipliedAlpha );\n\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\tinfo.programs = programCache.programs;\n\n\t\t_this.context = _gl;\n\t\t_this.capabilities = capabilities;\n\t\t_this.extensions = extensions;\n\t\t_this.properties = properties;\n\t\t_this.renderLists = renderLists;\n\t\t_this.state = state;\n\t\t_this.info = info;\n\n\t}\n\n\tinitGLContext();\n\n\t// vr\n\n\tvar vr = ( typeof navigator !== 'undefined' && 'xr' in navigator && 'supportsSession' in navigator.xr ) ? new WebXRManager( _this ) : new WebVRManager( _this );\n\n\tthis.vr = vr;\n\n\t// shadow map\n\n\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\n\n\tthis.shadowMap = shadowMap;\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t};\n\n\tthis.forceContextRestore = function () {\n\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.restoreContext();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _width, _height, false );\n\n\t};\n\n\tthis.getSize = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );\n\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set( _width, _height );\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\tif ( vr.isPresenting() ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = Math.floor( width * _pixelRatio );\n\t\t_canvas.height = Math.floor( height * _pixelRatio );\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );\n\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t};\n\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_pixelRatio = pixelRatio;\n\n\t\t_canvas.width = Math.floor( width * pixelRatio );\n\t\t_canvas.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getCurrentViewport = function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );\n\n\t\t\ttarget = new Vector4();\n\n\t\t}\n\n\t\treturn target.copy( _currentViewport );\n\n\t};\n\n\tthis.getViewport = function ( target ) {\n\n\t\treturn target.copy( _viewport );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_viewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissor = function ( target ) {\n\n\t\treturn target.copy( _scissor );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t} else {\n\n\t\t\t_scissor.set( x, y, width, height );\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn _scissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn background.getClearColor();\n\n\t};\n\n\tthis.setClearColor = function () {\n\n\t\tbackground.setClearColor.apply( background, arguments );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn background.getClearAlpha();\n\n\t};\n\n\tthis.setClearAlpha = function () {\n\n\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= 16384;\n\t\tif ( depth === undefined || depth ) bits |= 256;\n\t\tif ( stencil === undefined || stencil ) bits |= 1024;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\t//\n\n\tthis.dispose = function () {\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\trenderLists.dispose();\n\t\trenderStates.dispose();\n\t\tproperties.dispose();\n\t\tobjects.dispose();\n\n\t\tvr.dispose();\n\n\t\tanimation.stop();\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t_isContextLost = true;\n\n\t}\n\n\tfunction onContextRestore( /* event */ ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t_isContextLost = false;\n\n\t\tinitGLContext();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.remove( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tfunction renderObjectImmediate( object, program ) {\n\n\t\tobject.render( function ( object ) {\n\n\t\t\t_this.renderBufferImmediate( object, program );\n\n\t\t} );\n\n\t}\n\n\tthis.renderBufferImmediate = function ( object, program ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.position );\n\t\t\t_gl.bufferData( 34962, object.positionArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.position );\n\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.normal );\n\t\t\t_gl.bufferData( 34962, object.normalArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.normal );\n\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.uv );\n\t\t\t_gl.bufferData( 34962, object.uvArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.uv );\n\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.color );\n\t\t\t_gl.bufferData( 34962, object.colorArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.color );\n\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( 4, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\n\t\tif ( _currentGeometryProgram.geometry !== geometry.id ||\n\t\t\t_currentGeometryProgram.program !== program.id ||\n\t\t\t_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {\n\n\t\t\t_currentGeometryProgram.geometry = geometry.id;\n\t\t\t_currentGeometryProgram.program = program.id;\n\t\t\t_currentGeometryProgram.wireframe = material.wireframe === true;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\t\tvar rangeFactor = 1;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tvar attribute;\n\t\tvar renderer = bufferRenderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattribute = attributes.get( index );\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( attribute );\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( 34963, attribute.buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\t//\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( 4 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( 5 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( 6 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\trenderer.setMode( 2 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 3 );\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\trenderer.setMode( 0 );\n\n\t\t} else if ( object.isSprite ) {\n\n\t\t\trenderer.setMode( 4 );\n\n\t\t}\n\n\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry ) {\n\n\t\tif ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\n\t\t\t\t\tvar attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tvar buffer = attribute.buffer;\n\t\t\t\t\tvar type = attribute.type;\n\t\t\t\t\tvar bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Compile\n\n\tthis.compile = function ( scene, camera ) {\n\n\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\tcurrentRenderState.init();\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcurrentRenderState.setupLights( camera );\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.material ) {\n\n\t\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\t\tfor ( var i = 0; i < object.material.length; i ++ ) {\n\n\t\t\t\t\t\tinitMaterial( object.material[ i ], scene.fog, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinitMaterial( object.material, scene.fog, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\t// Animation Loop\n\n\tvar onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time ) {\n\n\t\tif ( vr.isPresenting() ) return;\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tvar animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tif ( typeof window !== 'undefined' ) animation.setContext( window );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\t\tvr.setAnimationLoop( callback );\n\n\t\tanimation.start();\n\n\t};\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tvar renderTarget, forceClear;\n\n\t\tif ( arguments[ 2 ] !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );\n\t\t\trenderTarget = arguments[ 2 ];\n\n\t\t}\n\n\t\tif ( arguments[ 3 ] !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );\n\t\t\tforceClear = arguments[ 3 ];\n\n\t\t}\n\n\t\tif ( ! ( camera && camera.isCamera ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( _isContextLost ) return;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram.geometry = null;\n\t\t_currentGeometryProgram.program = null;\n\t\t_currentGeometryProgram.wireframe = false;\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tif ( vr.enabled ) {\n\n\t\t\tcamera = vr.getCamera( camera );\n\n\t\t}\n\n\t\t//\n\n\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\tcurrentRenderState.init();\n\n\t\tscene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tcurrentRenderList = renderLists.get( scene, camera );\n\t\tcurrentRenderList.init();\n\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\tcurrentRenderList.sort();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\tcurrentRenderState.setupLights( camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\tif ( this.info.autoReset ) this.info.reset();\n\n\t\tif ( renderTarget !== undefined ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tbackground.render( currentRenderList, scene, camera, forceClear );\n\n\t\t// render scene\n\n\t\tvar opaqueObjects = currentRenderList.opaque;\n\t\tvar transparentObjects = currentRenderList.transparent;\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\n\n\t\t}\n\n\t\t//\n\n\t\tscene.onAfterRender( _this, scene, camera );\n\n\t\t//\n\n\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.buffers.depth.setTest( true );\n\t\tstate.buffers.depth.setMask( true );\n\t\tstate.buffers.color.setMask( true );\n\n\t\tstate.setPolygonOffset( false );\n\n\t\tif ( vr.enabled ) {\n\n\t\t\tvr.submitFrame();\n\n\t\t}\n\n\t\t// _gl.finish();\n\n\t\tcurrentRenderList = null;\n\t\tcurrentRenderState = null;\n\n\t};\n\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tvar visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\t_currentArrayCamera = camera;\n\n\t\t\t\tvar cameras = camera.cameras;\n\n\t\t\t\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\n\n\t\t\t\t\t\tcurrentRenderState.setupLights( camera2 );\n\n\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_currentArrayCamera = null;\n\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\tstate.setMaterial( material );\n\n\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t_currentGeometryProgram.geometry = null;\n\t\t\t_currentGeometryProgram.program = null;\n\t\t\t_currentGeometryProgram.wireframe = false;\n\n\t\t\trenderObjectImmediate( object, program );\n\n\t\t} else {\n\n\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t}\n\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar lights = currentRenderState.state.lights;\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tvar lightsStateVersion = lights.state.version;\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {\n\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tprogramChange = false;\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.onBeforeCompile( materialProperties.shader, _this );\n\n\t\t\t// Computing code again as onBeforeCompile may have changed the shaders\n\t\t\tcode = programCache.getProgramCode( material, parameters );\n\n\t\t\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.shader.uniforms;\n\n\t\tif ( ! material.isShaderMaterial &&\n\t\t\t! material.isRawShaderMaterial ||\n\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tmaterialProperties.fog = fog;\n\n\t\t// store the light setup it was created for\n\n\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\tif ( material.lights ) {\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\ttextures.resetTextureUnits();\n\n\t\tvar materialProperties = properties.get( material );\n\t\tvar lights = currentRenderState.state.lights;\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.needsUpdate === false ) {\n\n\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( material.lights && materialProperties.lightsStateVersion !== lights.state.version ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\n\t\t\t\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.shader.uniforms;\n\n\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\tmaterial.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tvar bones = skeleton.bones;\n\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === undefined ) {\n\n\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\t\t\t\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\t\t\tsize = _Math.ceilPowerOfTwo( size );\n\t\t\t\t\t\tsize = Math.max( size, 4 );\n\n\t\t\t\t\t\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\n\n\t\t\t\t\t\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\t\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\n\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\n\t\t\t\t\t\tskeleton.boneTextureSize = size;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\tif ( material.isMeshToonMaterial ) {\n\n\t\t\t\t\trefreshUniformsToon( m_uniforms, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\trefreshUniformsMatcap( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsDepth( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsDistance( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsNormal( m_uniforms, material );\n\n\t\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\t\trefreshUniformsSprites( m_uniforms, material );\n\n\t\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\t\tm_uniforms.color.value.copy( material.color );\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\t// RectAreaLight Texture\n\t\t\t// TODO (mrdoob): Find a nicer implementation\n\n\t\t\tif ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;\n\t\t\tif ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\n\t\t}\n\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t}\n\n\t\t// common matrices\n\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\tuniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _height * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\n\t\t\t\tmaterial.map.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\n\t\t\t\tmaterial.map.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value.copy( fog.color );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\trefreshUniformsPhong( uniforms, material );\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDepth( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\tuniforms.farDistance.value = material.farDistance;\n\n\t}\n\n\tfunction refreshUniformsNormal( uniforms, material ) {\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t//\n\tthis.setFramebuffer = function ( value ) {\n\n\t\tif ( _framebuffer !== value ) _gl.bindFramebuffer( 36160, value );\n\n\t\t_framebuffer = value;\n\n\t};\n\n\tthis.getActiveCubeFace = function () {\n\n\t\treturn _currentActiveCubeFace;\n\n\t};\n\n\tthis.getActiveMipMapLevel = function () {\n\n\t\treturn _currentActiveMipmapLevel;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipMapLevel ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t_currentActiveMipmapLevel = activeMipMapLevel;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar framebuffer = _framebuffer;\n\t\tvar isCube = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace || 0 ];\n\t\t\t\tisCube = true;\n\n\t\t\t} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t} else {\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport );\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipMapLevel || 0 );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( renderTarget.isWebGLRenderTargetCube && activeCubeFaceIndex !== undefined ) {\n\n\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t}\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\n\n\t\tvar width = texture.image.width;\n\t\tvar height = texture.image.height;\n\t\tvar glFormat = utils.convert( texture.format );\n\n\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );\n\n\t};\n\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {\n\n\t\tvar width = srcTexture.image.width;\n\t\tvar height = srcTexture.image.height;\n\t\tvar glFormat = utils.convert( dstTexture.format );\n\t\tvar glType = utils.convert( dstTexture.type );\n\n\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t} else {\n\n\t\t\t_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t}\n\n\t};\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction FogExp2( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n}\n\nObject.assign( FogExp2.prototype, {\n\n\tisFogExp2: true,\n\n\tclone: function () {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t},\n\n\ttoJSON: function ( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Fog( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n}\n\nObject.assign( Fog.prototype, {\n\n\tisFog: true,\n\n\tclone: function () {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InterleavedBuffer( array, stride ) {\n\n\tthis.array = array;\n\tthis.stride = stride;\n\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( InterleavedBuffer.prototype, {\n\n\tisInterleavedBuffer: true,\n\n\tonUploadCallback: function () {},\n\n\tsetArray: function ( array ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\tthis.array = array;\n\n\t\treturn this;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n\tthis.normalized = normalized === true;\n\n}\n\nObject.defineProperties( InterleavedBufferAttribute.prototype, {\n\n\tcount: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.count;\n\n\t\t}\n\n\t},\n\n\tarray: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.array;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( InterleavedBufferAttribute.prototype, {\n\n\tisInterleavedBufferAttribute: true,\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nfunction SpriteMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\tthis.transparent = true;\n\n\tthis.setValues( parameters );\n\n}\n\nSpriteMaterial.prototype = Object.create( Material.prototype );\nSpriteMaterial.prototype.constructor = SpriteMaterial;\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nSpriteMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar geometry;\n\nfunction Sprite( material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tif ( geometry === undefined ) {\n\n\t\tgeometry = new BufferGeometry();\n\n\t\tvar float32Array = new Float32Array( [\n\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t] );\n\n\t\tvar interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\tgeometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\tgeometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t}\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\tthis.center = new Vector2( 0.5, 0.5 );\n\n}\n\nSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Sprite,\n\n\tisSprite: true,\n\n\traycast: ( function () {\n\n\t\tvar intersectPoint = new Vector3();\n\t\tvar worldScale = new Vector3();\n\t\tvar mvPosition = new Vector3();\n\n\t\tvar alignedPosition = new Vector2();\n\t\tvar rotatedPosition = new Vector2();\n\t\tvar viewWorldMatrix = new Matrix4();\n\n\t\tvar vA = new Vector3();\n\t\tvar vB = new Vector3();\n\t\tvar vC = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t\t\t// compute position in camera space\n\t\t\talignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t\t\t// to check if rotation is not zero\n\t\t\tif ( sin !== undefined ) {\n\n\t\t\t\trotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );\n\t\t\t\trotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );\n\n\t\t\t} else {\n\n\t\t\t\trotatedPosition.copy( alignedPosition );\n\n\t\t\t}\n\n\n\t\t\tvertexPosition.copy( mvPosition );\n\t\t\tvertexPosition.x += rotatedPosition.x;\n\t\t\tvertexPosition.y += rotatedPosition.y;\n\n\t\t\t// transform to world space\n\t\t\tvertexPosition.applyMatrix4( viewWorldMatrix );\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tworldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t\tviewWorldMatrix.copy( raycaster._camera.matrixWorld );\n\t\t\tthis.modelViewMatrix.multiplyMatrices( raycaster._camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t\tmvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\t\tif ( raycaster._camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t\tworldScale.multiplyScalar( - mvPosition.z );\n\n\t\t\t}\n\n\t\t\tvar rotation = this.material.rotation;\n\t\t\tvar sin, cos;\n\t\t\tif ( rotation !== 0 ) {\n\n\t\t\t\tcos = Math.cos( rotation );\n\t\t\t\tsin = Math.sin( rotation );\n\n\t\t\t}\n\n\t\t\tvar center = this.center;\n\n\t\t\ttransformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\ttransformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\ttransformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\n\t\t\tuvA.set( 0, 0 );\n\t\t\tuvB.set( 1, 0 );\n\t\t\tuvC.set( 1, 1 );\n\n\t\t\t// check first triangle\n\t\t\tvar intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );\n\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\t// check second triangle\n\t\t\t\ttransformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\t\tuvB.set( 0, 1 );\n\n\t\t\t\tintersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );\n\t\t\t\tif ( intersect === null ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\tuv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\treturn this;\n\n\t}\n\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LOD() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n\tthis.autoUpdate = true;\n\n}\n\nLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: LOD,\n\n\tisLOD: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nfunction SkinnedMesh( geometry, material ) {\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\tconsole.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t}\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = 'attached';\n\tthis.bindMatrix = new Matrix4();\n\tthis.bindMatrixInverse = new Matrix4();\n\n}\n\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: SkinnedMesh,\n\n\tisSkinnedMesh: true,\n\n\tbind: function ( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tvar vector = new Vector4();\n\n\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( var i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tvar scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nfunction Skeleton( bones, boneInverses ) {\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tvar inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ i ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone, i, il;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tbone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tbone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new Matrix4();\n\t\tvar identityMatrix = new Matrix4();\n\n\t\treturn function update() {\n\n\t\t\tvar bones = this.bones;\n\t\t\tvar boneInverses = this.boneInverses;\n\t\t\tvar boneMatrices = this.boneMatrices;\n\t\t\tvar boneTexture = this.boneTexture;\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t\toffsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t\t}\n\n\t\t\tif ( boneTexture !== undefined ) {\n\n\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t},\n\n\tgetBoneByName: function ( name ) {\n\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nfunction Bone() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Bone';\n\n}\n\nBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Bone,\n\n\tisBone: true\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nfunction LineBasicMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nLineBasicMaterial.prototype = Object.create( Material.prototype );\nLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nLineBasicMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Line( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );\n\n\t}\n\n\tObject3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n}\n\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Line,\n\n\tisLine: true,\n\n\tcomputeLineDistances: ( function () {\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\tvar lineDistances = [ 0 ];\n\n\t\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i ] += start.distanceTo( end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\tlineDistances[ 0 ] = 0;\n\n\t\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() ),\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\tsphere.radius += precision;\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localPrecisionSq = localPrecision * localPrecision;\n\n\t\t\tvar vStart = new Vector3();\n\t\t\tvar vEnd = new Vector3();\n\t\t\tvar interSegment = new Vector3();\n\t\t\tvar interRay = new Vector3();\n\t\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LineSegments( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n}\n\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineSegments,\n\n\tisLineSegments: true,\n\n\tcomputeLineDistances: ( function () {\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\tvar lineDistances = [];\n\n\t\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\n\n\t\t\t\t\tstart.copy( vertices[ i ] );\n\t\t\t\t\tend.copy( vertices[ i + 1 ] );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() )\n\n} );\n\n/**\n * @author mgreter / http://github.com/mgreter\n */\n\nfunction LineLoop( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineLoop';\n\n}\n\nLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineLoop,\n\n\tisLineLoop: true,\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n *  morphTargets: <bool>\n * }\n */\n\nfunction PointsMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nPointsMaterial.prototype = Object.create( Material.prototype );\nPointsMaterial.prototype.constructor = PointsMaterial;\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nPointsMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Points( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.updateMorphTargets();\n\n}\n\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Points,\n\n\tisPoints: true,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\tsphere.radius += threshold;\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new Vector3();\n\t\t\tvar intersectPoint = new Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tray.closestPointToPoint( point, intersectPoint );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tupdateMorphTargets: function () {\n\n\t\tvar geometry = this.geometry;\n\t\tvar m, ml, name;\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\t\tvar keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.format = format !== undefined ? format : RGBFormat;\n\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\tthis.generateMipmaps = false;\n\n}\n\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\n\tconstructor: VideoTexture,\n\n\tisVideoTexture: true,\n\n\tupdate: function () {\n\n\t\tvar video = this.image;\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n}\n\nCompressedTexture.prototype = Object.create( Texture.prototype );\nCompressedTexture.prototype.constructor = CompressedTexture;\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n}\n\nCanvasTexture.prototype = Object.create( Texture.prototype );\nCanvasTexture.prototype.constructor = CanvasTexture;\nCanvasTexture.prototype.isCanvasTexture = true;\n\n/**\n * @author Matt DesLauriers / @mattdesl\n * @author atix / arthursilber.de\n */\n\nfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\tformat = format !== undefined ? format : DepthFormat;\n\n\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t}\n\n\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps\t= false;\n\n}\n\nDepthTexture.prototype = Object.create( Texture.prototype );\nDepthTexture.prototype.constructor = DepthTexture;\nDepthTexture.prototype.isDepthTexture = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WireframeGeometry( geometry ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'WireframeGeometry';\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar i, j, l, o, ol;\n\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\tvar vertex;\n\n\t// different logic for Geometry and BufferGeometry\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\t// create a data structure that contains all edges without duplicates\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices\n\n\t\tfor ( key in edges ) {\n\n\t\t\te = edges[ key ];\n\n\t\t\tvertex = geometry.vertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t} else if ( geometry && geometry.isBufferGeometry ) {\n\n\t\tvar position, indices, groups;\n\t\tvar group, start, count;\n\t\tvar index1, index2;\n\n\t\tvertex = new Vector3();\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\t\t\tindices = geometry.index;\n\t\t\tgroups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t}\n\n\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tgroup = groups[ o ];\n\n\t\t\t\tstart = group.start;\n\t\t\t\tcount = group.count;\n\n\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge1 = indices.getX( i + j );\n\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( key in edges ) {\n\n\t\t\t\te = edges[ key ];\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\n\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\tindex1 = 3 * i + j;\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\nWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n */\n\n// ParametricGeometry\n\nfunction ParametricGeometry( func, slices, stacks ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\tthis.mergeVertices();\n\n}\n\nParametricGeometry.prototype = Object.create( Geometry.prototype );\nParametricGeometry.prototype.constructor = ParametricGeometry;\n\n// ParametricBufferGeometry\n\nfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ParametricBufferGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tvar EPS = 0.00001;\n\n\tvar normal = new Vector3();\n\n\tvar p0 = new Vector3(), p1 = new Vector3();\n\tvar pu = new Vector3(), pv = new Vector3();\n\n\tvar i, j;\n\n\tif ( func.length < 3 ) {\n\n\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t}\n\n\t// generate vertices, normals and uvs\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tvar v = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tvar u = j / slices;\n\n\t\t\t// vertex\n\n\t\t\tfunc( u, v, p0 );\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t// normal\n\n\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\tvar a = i * sliceCount + j;\n\t\t\tvar b = i * sliceCount + j + 1;\n\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\tvar d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t// faces one and two\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// PolyhedronGeometry\n\nfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n// PolyhedronBufferGeometry\n\nfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'PolyhedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\t// default buffer data\n\n\tvar vertexBuffer = [];\n\tvar uvBuffer = [];\n\n\t// the subdivision creates the vertex buffer data\n\n\tsubdivide( detail );\n\n\t// all vertices should lie on a conceptual sphere with a given radius\n\n\tappplyRadius( radius );\n\n\t// finally, create the uv data\n\n\tgenerateUVs();\n\n\t// build non-indexed geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\tif ( detail === 0 ) {\n\n\t\tthis.computeVertexNormals(); // flat normals\n\n\t} else {\n\n\t\tthis.normalizeNormals(); // smooth normals\n\n\t}\n\n\t// helper functions\n\n\tfunction subdivide( detail ) {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t// get the vertices of the face\n\n\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t// perform subdivision\n\n\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t}\n\n\t}\n\n\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\n\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\tvar v = [];\n\n\t\tvar i, j;\n\n\t\t// construct all of the vertices for this subdivision\n\n\t\tfor ( i = 0; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// construct all of the faces\n\n\t\tfor ( i = 0; i < cols; i ++ ) {\n\n\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction appplyRadius( radius ) {\n\n\t\tvar vertex = new Vector3();\n\n\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t}\n\n\t}\n\n\tfunction generateUVs() {\n\n\t\tvar vertex = new Vector3();\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t}\n\n\t\tcorrectUVs();\n\n\t\tcorrectSeam();\n\n\t}\n\n\tfunction correctSeam() {\n\n\t\t// handle case when face straddles the seam, see #3269\n\n\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t// uv data of a single face\n\n\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction pushVertex( vertex ) {\n\n\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t}\n\n\tfunction getVertexByIndex( index, vertex ) {\n\n\t\tvar stride = index * 3;\n\n\t\tvertex.x = vertices[ stride + 0 ];\n\t\tvertex.y = vertices[ stride + 1 ];\n\t\tvertex.z = vertices[ stride + 2 ];\n\n\t}\n\n\tfunction correctUVs() {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\tvar centroid = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\tvar azi = azimuth( centroid );\n\n\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t}\n\n\t}\n\n\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t}\n\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t}\n\n\t}\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n}\n\nPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// TetrahedronGeometry\n\nfunction TetrahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\nTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n// TetrahedronBufferGeometry\n\nfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// OctahedronGeometry\n\nfunction OctahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nOctahedronGeometry.prototype = Object.create( Geometry.prototype );\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n// OctahedronBufferGeometry\n\nfunction OctahedronBufferGeometry( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t1, 3, 4,\t1, 4, 2\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// IcosahedronGeometry\n\nfunction IcosahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\nIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n// IcosahedronBufferGeometry\n\nfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t 0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t t, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t];\n\n\tvar indices = [\n\t\t 0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t 1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t 3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t 4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n/**\n * @author Abe Pazos / https://hamoid.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// DodecahedronGeometry\n\nfunction DodecahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\nDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n// DodecahedronBufferGeometry\n\nfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (±1, ±1, ±1)\n\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t// (0, ±1/φ, ±φ)\n\t\t 0, - r, - t, 0, - r, t,\n\t\t 0, r, - t, 0, r, t,\n\n\t\t// (±1/φ, ±φ, 0)\n\t\t- r, - t, 0, - r, t, 0,\n\t\t r, - t, 0, r, t, 0,\n\n\t\t// (±φ, 0, ±1/φ)\n\t\t- t, 0, - r, t, 0, - r,\n\t\t- t, 0, r, t, 0, r\n\t];\n\n\tvar indices = [\n\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n/**\n * @author oosmoxiecode / https://github.com/oosmoxiecode\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n * @author Mugen87 / https://github.com/Mugen87\n *\n */\n\n// TubeGeometry\n\nfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\ttubularSegments: tubularSegments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed\n\t};\n\n\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t// expose internals\n\n\tthis.tangents = bufferGeometry.tangents;\n\tthis.normals = bufferGeometry.normals;\n\tthis.binormals = bufferGeometry.binormals;\n\n\t// create geometry\n\n\tthis.fromBufferGeometry( bufferGeometry );\n\tthis.mergeVertices();\n\n}\n\nTubeGeometry.prototype = Object.create( Geometry.prototype );\nTubeGeometry.prototype.constructor = TubeGeometry;\n\n// TubeBufferGeometry\n\nfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TubeBufferGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\ttubularSegments: tubularSegments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed\n\t};\n\n\ttubularSegments = tubularSegments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\n\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t// expose internals\n\n\tthis.tangents = frames.tangents;\n\tthis.normals = frames.normals;\n\tthis.binormals = frames.binormals;\n\n\t// helper variables\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\tvar uv = new Vector2();\n\tvar P = new Vector3();\n\n\tvar i, j;\n\n\t// buffer\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\tvar indices = [];\n\n\t// create buffer data\n\n\tgenerateBufferData();\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// functions\n\n\tfunction generateBufferData() {\n\n\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\tgenerateSegment( i );\n\n\t\t}\n\n\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t// at the regular position on the given path\n\t\t//\n\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t// uvs are generated in a separate function.\n\t\t// this makes it easy compute correct values for closed geometries\n\n\t\tgenerateUVs();\n\n\t\t// finally create faces\n\n\t\tgenerateIndices();\n\n\t}\n\n\tfunction generateSegment( i ) {\n\n\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t// retrieve corresponding normal and binormal\n\n\t\tvar N = frames.normals[ i ];\n\t\tvar B = frames.binormals[ i ];\n\n\t\t// generate normals and vertices for the current segment\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\tvar sin = Math.sin( v );\n\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t// normal\n\n\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\tnormal.normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t}\n\n\tfunction generateIndices() {\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction generateUVs() {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\nTubeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tdata.path = this.parameters.path.toJSON();\n\n\treturn data;\n\n};\n\n/**\n * @author oosmoxiecode\n * @author Mugen87 / https://github.com/Mugen87\n *\n * based on http://www.blackpawn.com/texts/pqtorus/\n */\n\n// TorusKnotGeometry\n\nfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n}\n\nTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n// TorusKnotBufferGeometry\n\nfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 1;\n\ttube = tube || 0.4;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar i, j;\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\tvar P1 = new Vector3();\n\tvar P2 = new Vector3();\n\n\tvar B = new Vector3();\n\tvar T = new Vector3();\n\tvar N = new Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( i / tubularSegments );\n\t\t\tuvs.push( j / radialSegments );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n}\n\nTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// TorusGeometry\n\nfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\tthis.mergeVertices();\n\n}\n\nTorusGeometry.prototype = Object.create( Geometry.prototype );\nTorusGeometry.prototype.constructor = TorusGeometry;\n\n// TorusBufferGeometry\n\nfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 1;\n\ttube = tube || 0.4;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar center = new Vector3();\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( i / tubularSegments );\n\t\t\tuvs.push( j / radialSegments );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n * Port from https://github.com/mapbox/earcut (v2.1.5)\n */\n\nvar Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim ) {\n\n\t\tdim = dim || 2;\n\n\t\tvar hasHoles = holeIndices && holeIndices.length,\n\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\n\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\n\t\t\ttriangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tvar minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tvar i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tvar p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tvar stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim );\n\t\t\ttriangles.push( ear.i / dim );\n\t\t\ttriangles.push( next.i / dim );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tvar a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tvar p = ear.next.next;\n\n\twhile ( p !== ear.prev ) {\n\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tvar a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\n\t// z-order range for the current triangle bbox;\n\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\n\tvar p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n !== ear.prev && n !== ear.next &&\n\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&\n\t\t\tarea( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tvar p = start;\n\tdo {\n\n\t\tvar a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim );\n\t\t\ttriangles.push( p.i / dim );\n\t\t\ttriangles.push( b.i / dim );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn p;\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tvar a = start;\n\tdo {\n\n\t\tvar b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tvar c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tvar queue = [],\n\t\ti, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\teliminateHole( queue[ i ], outerNode );\n\t\touterNode = filterPoints( outerNode, outerNode.next );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\touterNode = findHoleBridge( hole, outerNode );\n\tif ( outerNode ) {\n\n\t\tvar b = splitPolygon( outerNode, hole );\n\t\tfilterPoints( b, b.next );\n\n\t}\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tvar p = outerNode,\n\t\thx = hole.x,\n\t\thy = hole.y,\n\t\tqx = - Infinity,\n\t\tm;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tif ( x === hx ) {\n\n\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\n\t\t\t\t}\n\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tvar stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y,\n\t\ttanMin = Infinity,\n\t\ttan;\n\n\tp = m.next;\n\n\twhile ( p !== stop ) {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t}\n\n\treturn m;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tvar p = start;\n\tdo {\n\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tvar i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = 32767 * ( x - minX ) * invSize;\n\ty = 32767 * ( y - minY ) * invSize;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tvar p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t\t   ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t\t   ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\n\t\t   locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tif ( ( equals( p1, p2 ) && equals( q1, q2 ) ) ||\n\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\n\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\n\t\t   area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tvar p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tvar p = a,\n\t\tinside = false,\n\t\tpx = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tvar a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tvar p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = null;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tvar sum = 0;\n\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nvar ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tvar holeIndices = []; // array of hole indices\n\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tvar holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( var i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n};\n\nfunction removeDupEndPts( points ) {\n\n\tvar l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( var i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n// ExtrudeGeometry\n\nfunction ExtrudeGeometry( shapes, options ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\tthis.mergeVertices();\n\n}\n\nExtrudeGeometry.prototype = Object.create( Geometry.prototype );\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\nExtrudeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n// ExtrudeBufferGeometry\n\nfunction ExtrudeBufferGeometry( shapes, options ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ExtrudeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tvar scope = this;\n\n\tvar verticesArray = [];\n\tvar uvArray = [];\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tvar shape = shapes[ i ];\n\t\taddShape( shape );\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\tthis.computeVertexNormals();\n\n\t// functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar placeholder = [];\n\n\t\t// options\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\tvar bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar extrudePath = options.extrudePath;\n\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t// deprecated options\n\n\t\tif ( options.amount !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\tdepth = options.amount;\n\n\t\t}\n\n\t\t//\n\n\t\tvar extrudePts, extrudeByPath = false;\n\t\tvar splineTube, binormal, normal, position2;\n\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\t\t\tbevelOffset = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [],\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize + bevelOffset;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0,\n\t\t\t\t\tsl = steps + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tplaceholder.push( x );\n\t\t\tplaceholder.push( y );\n\t\t\tplaceholder.push( z );\n\n\t\t}\n\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( d );\n\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\t\t\taddVertex( d );\n\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t}\n\n\t\tfunction addVertex( index ) {\n\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t}\n\n\n\t\tfunction addUV( vector2 ) {\n\n\t\t\tuvArray.push( vector2.x );\n\t\t\tuvArray.push( vector2.y );\n\n\t\t}\n\n\t}\n\n}\n\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\nExtrudeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n//\n\nvar WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\n\t\tvar d_x = vertices[ indexD * 3 ];\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\t//\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\t//\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n *  bevelOffset: <float> // how far from text outline does bevel start\n * }\n */\n\n// TextGeometry\n\nfunction TextGeometry( text, parameters ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TextGeometry';\n\n\tthis.parameters = {\n\t\ttext: text,\n\t\tparameters: parameters\n\t};\n\n\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\n\tthis.mergeVertices();\n\n}\n\nTextGeometry.prototype = Object.create( Geometry.prototype );\nTextGeometry.prototype.constructor = TextGeometry;\n\n// TextBufferGeometry\n\nfunction TextBufferGeometry( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( ! ( font && font.isFont ) ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tExtrudeBufferGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextBufferGeometry';\n\n}\n\nTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\nTextBufferGeometry.prototype.constructor = TextBufferGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author benaadams / https://twitter.com/ben_a_adams\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// SphereGeometry\n\nfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nSphereGeometry.prototype = Object.create( Geometry.prototype );\nSphereGeometry.prototype.constructor = SphereGeometry;\n\n// SphereBufferGeometry\n\nfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 1;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\tvar ix, iy;\n\n\tvar index = 0;\n\tvar grid = [];\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// generate vertices, normals and uvs\n\n\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = iy / heightSegments;\n\n\t\t// special case for the poles\n\n\t\tvar uOffset = 0;\n\n\t\tif ( iy == 0 && thetaStart == 0 ) {\n\n\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\n\n\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t}\n\n\t\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\tvar u = ix / widthSegments;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormal.copy( vertex ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\tverticesRow.push( index ++ );\n\n\t\t}\n\n\t\tgrid.push( verticesRow );\n\n\t}\n\n\t// indices\n\n\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\tvar a = grid[ iy ][ ix + 1 ];\n\t\t\tvar b = grid[ iy ][ ix ];\n\t\t\tvar c = grid[ iy + 1 ][ ix ];\n\t\t\tvar d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n/**\n * @author Kaleb Murphy\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// RingGeometry\n\nfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nRingGeometry.prototype = Object.create( Geometry.prototype );\nRingGeometry.prototype.constructor = RingGeometry;\n\n// RingBufferGeometry\n\nfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 0.5;\n\touterRadius = outerRadius || 1;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// some helper variables\n\n\tvar segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uv\n\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\n\t\tradius += radiusStep;\n\n\t}\n\n\t// indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// LatheGeometry\n\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n}\n\nLatheGeometry.prototype = Object.create( Geometry.prototype );\nLatheGeometry.prototype.constructor = LatheGeometry;\n\n// LatheBufferGeometry\n\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar base;\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif ( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new Vector3();\n\t\tvar n2 = new Vector3();\n\t\tvar n = new Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\n\t\tbase = segments * points.length * 3;\n\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t}\n\n\t}\n\n}\n\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n/**\n * @author jonobr1 / http://jonobr1.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// ShapeGeometry\n\nfunction ShapeGeometry( shapes, curveSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( typeof curveSegments === 'object' ) {\n\n\t\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\n\t\tcurveSegments = curveSegments.curveSegments;\n\n\t}\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n\tthis.mergeVertices();\n\n}\n\nShapeGeometry.prototype = Object.create( Geometry.prototype );\nShapeGeometry.prototype.constructor = ShapeGeometry;\n\nShapeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON$1( shapes, data );\n\n};\n\n// ShapeBufferGeometry\n\nfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ShapeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tcurveSegments = curveSegments || 12;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar groupStart = 0;\n\tvar groupCount = 0;\n\n\t// allow single and array values for \"shapes\" parameter\n\n\tif ( Array.isArray( shapes ) === false ) {\n\n\t\taddShape( shapes );\n\n\t} else {\n\n\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\n\n\t\t\taddShape( shapes[ i ] );\n\n\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\tgroupStart += groupCount;\n\t\t\tgroupCount = 0;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t// helper functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar i, l, shapeHole;\n\n\t\tvar indexOffset = vertices.length / 3;\n\t\tvar points = shape.extractPoints( curveSegments );\n\n\t\tvar shapeVertices = points.shape;\n\t\tvar shapeHoles = points.holes;\n\n\t\t// check direction of vertices\n\n\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t}\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t// join vertices of inner and outer paths to a single array\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t}\n\n\t\t// vertices, normals, uvs\n\n\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\tvar vertex = shapeVertices[ i ];\n\n\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\tnormals.push( 0, 0, 1 );\n\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t}\n\n\t\t// incides\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + indexOffset;\n\t\t\tvar b = face[ 1 ] + indexOffset;\n\t\t\tvar c = face[ 2 ] + indexOffset;\n\n\t\t\tindices.push( a, b, c );\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t}\n\n}\n\nShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\nShapeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON$1( shapes, data );\n\n};\n\n//\n\nfunction toJSON$1( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'EdgesGeometry';\n\n\tthis.parameters = {\n\t\tthresholdAngle: thresholdAngle\n\t};\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\n\t// prepare source geometry\n\n\tvar geometry2;\n\n\tif ( geometry.isBufferGeometry ) {\n\n\t\tgeometry2 = new Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar sourceVertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\t// now create a data structure where each entry represents an edge with its adjoining faces\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\n\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\tedges[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// generate vertices\n\n\tfor ( key in edges ) {\n\n\t\tvar e = edges[ key ];\n\n\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = sourceVertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = sourceVertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\nEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// CylinderGeometry\n\nfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nCylinderGeometry.prototype = Object.create( Geometry.prototype );\nCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n// CylinderBufferGeometry\n\nfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\theight = height || 1;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar index = 0;\n\tvar indexArray = [];\n\tvar halfHeight = height / 2;\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new Vector3();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\tvar a = indexArray[ y ][ x ];\n\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t// update group counter\n\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new Vector2();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\n\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\n\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t}\n\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n}\n\nCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\n// ConeGeometry\n\nfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n}\n\nConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\nConeGeometry.prototype.constructor = ConeGeometry;\n\n// ConeBufferGeometry\n\nfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n}\n\nConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\nConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * @author Mugen87 / https://github.com/Mugen87\n * @author hughes\n */\n\n// CircleGeometry\n\nfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nCircleGeometry.prototype = Object.create( Geometry.prototype );\nCircleGeometry.prototype.constructor = CircleGeometry;\n\n// CircleBufferGeometry\n\nfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 1;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar i, s;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\n\t// center point\n\n\tvertices.push( 0, 0, 0 );\n\tnormals.push( 0, 0, 1 );\n\tuvs.push( 0.5, 0.5 );\n\n\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t// vertex\n\n\t\tvertex.x = radius * Math.cos( segment );\n\t\tvertex.y = radius * Math.sin( segment );\n\n\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t// normal\n\n\t\tnormals.push( 0, 0, 1 );\n\n\t\t// uvs\n\n\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\tuvs.push( uv.x, uv.y );\n\n\t}\n\n\t// indices\n\n\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\tWireframeGeometry: WireframeGeometry,\n\tParametricGeometry: ParametricGeometry,\n\tParametricBufferGeometry: ParametricBufferGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\tTubeGeometry: TubeGeometry,\n\tTubeBufferGeometry: TubeBufferGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusBufferGeometry: TorusBufferGeometry,\n\tTextGeometry: TextGeometry,\n\tTextBufferGeometry: TextBufferGeometry,\n\tSphereGeometry: SphereGeometry,\n\tSphereBufferGeometry: SphereBufferGeometry,\n\tRingGeometry: RingGeometry,\n\tRingBufferGeometry: RingBufferGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPlaneBufferGeometry: PlaneBufferGeometry,\n\tLatheGeometry: LatheGeometry,\n\tLatheBufferGeometry: LatheBufferGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tShapeBufferGeometry: ShapeBufferGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tConeGeometry: ConeGeometry,\n\tConeBufferGeometry: ConeBufferGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tCylinderBufferGeometry: CylinderBufferGeometry,\n\tCircleGeometry: CircleGeometry,\n\tCircleBufferGeometry: CircleBufferGeometry,\n\tBoxGeometry: BoxGeometry,\n\tBoxBufferGeometry: BoxBufferGeometry\n});\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\nfunction ShadowMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShadowMaterial';\n\n\tthis.color = new Color( 0x000000 );\n\tthis.transparent = true;\n\n\tthis.setValues( parameters );\n\n}\n\nShadowMaterial.prototype = Object.create( Material.prototype );\nShadowMaterial.prototype.constructor = ShadowMaterial;\n\nShadowMaterial.prototype.isShadowMaterial = true;\n\nShadowMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction RawShaderMaterial( parameters ) {\n\n\tShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n}\n\nRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\nRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshStandardMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\nMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n *  clearCoat: <float>\n *  clearCoatRoughness: <float>\n * }\n */\n\nfunction MeshPhysicalMaterial( parameters ) {\n\n\tMeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\nMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshPhongMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.specular = new Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshPhongMaterial.prototype = Object.create( Material.prototype );\nMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\nMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author takahirox / http://github.com/takahirox\n *\n * parameters = {\n *  gradientMap: new THREE.Texture( <Image> )\n * }\n */\n\nfunction MeshToonMaterial( parameters ) {\n\n\tMeshPhongMaterial.call( this );\n\n\tthis.defines = { 'TOON': '' };\n\n\tthis.type = 'MeshToonMaterial';\n\n\tthis.gradientMap = null;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\nMeshToonMaterial.prototype.constructor = MeshToonMaterial;\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\nMeshToonMaterial.prototype.copy = function ( source ) {\n\n\tMeshPhongMaterial.prototype.copy.call( this, source );\n\n\tthis.gradientMap = source.gradientMap;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshNormalMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshNormalMaterial.prototype = Object.create( Material.prototype );\nMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\nMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshLambertMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshLambertMaterial.prototype = Object.create( Material.prototype );\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\nMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshMatcapMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'MATCAP': '' };\n\n\tthis.type = 'MeshMatcapMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\n\tthis.matcap = null;\n\n\tthis.map = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.alphaMap = null;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshMatcapMaterial.prototype = Object.create( Material.prototype );\nMeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\nMeshMatcapMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'MATCAP': '' };\n\n\tthis.color.copy( source.color );\n\n\tthis.matcap = source.matcap;\n\n\tthis.map = source.map;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nfunction LineDashedMaterial( parameters ) {\n\n\tLineBasicMaterial.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.setValues( parameters );\n\n}\n\nLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\nLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\nLineDashedMaterial.prototype.copy = function ( source ) {\n\n\tLineBasicMaterial.prototype.copy.call( this, source );\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n\n\nvar Materials = /*#__PURE__*/Object.freeze({\n\tShadowMaterial: ShadowMaterial,\n\tSpriteMaterial: SpriteMaterial,\n\tRawShaderMaterial: RawShaderMaterial,\n\tShaderMaterial: ShaderMaterial,\n\tPointsMaterial: PointsMaterial,\n\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\tMeshStandardMaterial: MeshStandardMaterial,\n\tMeshPhongMaterial: MeshPhongMaterial,\n\tMeshToonMaterial: MeshToonMaterial,\n\tMeshNormalMaterial: MeshNormalMaterial,\n\tMeshLambertMaterial: MeshLambertMaterial,\n\tMeshDepthMaterial: MeshDepthMaterial,\n\tMeshDistanceMaterial: MeshDistanceMaterial,\n\tMeshBasicMaterial: MeshBasicMaterial,\n\tMeshMatcapMaterial: MeshMatcapMaterial,\n\tLineDashedMaterial: LineDashedMaterial,\n\tLineBasicMaterial: LineBasicMaterial,\n\tMaterial: Material\n});\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nvar AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n}\n\nObject.assign( Interpolant.prototype, {\n\n\tevaluate: function ( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function () {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function ( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n} );\n\n//!\\ DECLARE ALIAS AFTER assign prototype !\nObject.assign( Interpolant.prototype, {\n\n\t//( 0, t, t0 ), returns this.resultBuffer\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t//( N-1, tN-1, t ), returns this.resultBuffer\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n} );\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = - 0;\n\tthis._offsetPrev = - 0;\n\tthis._weightNext = - 0;\n\tthis._offsetNext = - 0;\n\n}\n\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tvar sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n * @author tschw\n */\n\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: LinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: DiscreteInterpolant,\n\n\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\tthis.name = name;\n\n\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n}\n\n// Static methods\n\nObject.assign( KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\ttoJSON: function ( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n} );\n\nObject.assign( KeyframeTrack.prototype, {\n\n\tconstructor: KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function ( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function ( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t},\n\n\tgetInterpolation: function () {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function () {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function ( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function ( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function ( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function () {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor ( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function () {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\twriteIndex = 1,\n\t\t\tlastIndex = times.length - 1;\n\n\t\tfor ( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tvar values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tvar TypedKeyframeTrack = this.constructor;\n\t\tvar track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n} );\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction BooleanKeyframeTrack( name, times, values ) {\n\n\tKeyframeTrack.call( this, name, times, values );\n\n}\n\nBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: NumberKeyframeTrack,\n\n\tValueTypeName: 'number'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: QuaternionLinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nfunction AnimationClip( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tvar trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tvar times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nObject.assign( AnimationClip, {\n\n\tparse: function ( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\ttoJSON: function ( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t},\n\n\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function ( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || - 1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\nObject.assign( AnimationClip.prototype, {\n\n\tresetDuration: function () {\n\n\t\tvar tracks = this.tracks, duration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t},\n\n\ttrim: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tvalidate: function () {\n\n\t\tvar valid = true;\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\toptimize: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tclone: function () {\n\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new AnimationClip( this.name, this.duration, tracks );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false;\n\tvar itemsLoaded = 0;\n\tvar itemsTotal = 0;\n\tvar urlModifier = undefined;\n\n\t// Refer to #5689 for the reason why we don't set .onStart\n\t// in the constructor\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n\tthis.resolveURL = function ( url ) {\n\n\t\tif ( urlModifier ) {\n\n\t\t\treturn urlModifier( url );\n\n\t\t}\n\n\t\treturn url;\n\n\t};\n\n\tthis.setURLModifier = function ( transform ) {\n\n\t\turlModifier = transform;\n\t\treturn this;\n\n\t};\n\n}\n\nvar DefaultLoadingManager = new LoadingManager();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar loading = {};\n\nfunction FileLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( FileLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Check for data: URI\n\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\tif ( dataUriRegexResult ) {\n\n\t\t\tvar mimeType = dataUriRegexResult[ 1 ];\n\t\t\tvar isBase64 = !! dataUriRegexResult[ 2 ];\n\t\t\tvar data = dataUriRegexResult[ 3 ];\n\n\t\t\tdata = decodeURIComponent( data );\n\n\t\t\tif ( isBase64 ) data = atob( data );\n\n\t\t\ttry {\n\n\t\t\t\tvar response;\n\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\tvar view = new Uint8Array( data.length );\n\n\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Initialise array for duplicate requests\n\n\t\t\tloading[ url ] = [];\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.open( 'GET', url, true );\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tvar response = this.response;\n\n\t\t\t\tCache.add( url, response );\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\tfor ( var header in this.requestHeader ) {\n\n\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t}\n\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t},\n\n\tsetMimeType: function ( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t},\n\n\tsetRequestHeader: function ( value ) {\n\n\t\tthis.requestHeader = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io/\n */\n\nfunction AnimationLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( AnimationLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nfunction CompressedTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n}\n\nObject.assign( CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nfunction DataTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n}\n\nObject.assign( DataTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new DataTexture();\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction ImageLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( ImageLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction CubeTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( CubeTextureLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new CubeTexture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction TextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( TextureLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new Texture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tvar isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nfunction Curve() {\n\n\tthis.type = 'Curve';\n\n\tthis.arcLengthDivisions = 200;\n\n}\n\nObject.assign( Curve.prototype, {\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function ( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t},\n\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tvar normal = new Vector3();\n\n\t\tvar tangents = [];\n\t\tvar normals = [];\n\t\tvar binormals = [];\n\n\t\tvar vec = new Vector3();\n\t\tvar mat = new Matrix4();\n\n\t\tvar i, u, theta;\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tu = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tvar min = Number.MAX_VALUE;\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n} );\n\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'EllipseCurve';\n\n\tthis.aX = aX || 0;\n\tthis.aY = aY || 0;\n\n\tthis.xRadius = xRadius || 1;\n\tthis.yRadius = yRadius || 1;\n\n\tthis.aStartAngle = aStartAngle || 0;\n\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\n\n\tthis.aClockwise = aClockwise || false;\n\n\tthis.aRotation = aRotation || 0;\n\n}\n\nEllipseCurve.prototype = Object.create( Curve.prototype );\nEllipseCurve.prototype.constructor = EllipseCurve;\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar twoPi = Math.PI * 2;\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t// ensures that deltaAngle is 0 .. 2 PI\n\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\tif ( samePoints ) {\n\n\t\t\tdeltaAngle = 0;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = twoPi;\n\n\t\t}\n\n\t}\n\n\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\tdeltaAngle = - twoPi;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t}\n\n\t}\n\n\tvar angle = this.aStartAngle + t * deltaAngle;\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x - this.aX;\n\t\tvar ty = y - this.aY;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = tx * cos - ty * sin + this.aX;\n\t\ty = tx * sin + ty * cos + this.aY;\n\n\t}\n\n\treturn point.set( x, y );\n\n};\n\nEllipseCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.aX = source.aX;\n\tthis.aY = source.aY;\n\n\tthis.xRadius = source.xRadius;\n\tthis.yRadius = source.yRadius;\n\n\tthis.aStartAngle = source.aStartAngle;\n\tthis.aEndAngle = source.aEndAngle;\n\n\tthis.aClockwise = source.aClockwise;\n\n\tthis.aRotation = source.aRotation;\n\n\treturn this;\n\n};\n\n\nEllipseCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.aX = this.aX;\n\tdata.aY = this.aY;\n\n\tdata.xRadius = this.xRadius;\n\tdata.yRadius = this.yRadius;\n\n\tdata.aStartAngle = this.aStartAngle;\n\tdata.aEndAngle = this.aEndAngle;\n\n\tdata.aClockwise = this.aClockwise;\n\n\tdata.aRotation = this.aRotation;\n\n\treturn data;\n\n};\n\nEllipseCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.aX = json.aX;\n\tthis.aY = json.aY;\n\n\tthis.xRadius = json.xRadius;\n\tthis.yRadius = json.yRadius;\n\n\tthis.aStartAngle = json.aStartAngle;\n\tthis.aEndAngle = json.aEndAngle;\n\n\tthis.aClockwise = json.aClockwise;\n\n\tthis.aRotation = json.aRotation;\n\n\treturn this;\n\n};\n\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\tthis.type = 'ArcCurve';\n\n}\n\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\nArcCurve.prototype.constructor = ArcCurve;\n\nArcCurve.prototype.isArcCurve = true;\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nvar tmp = new Vector3();\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\n\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CatmullRomCurve3';\n\n\tthis.points = points || [];\n\tthis.closed = closed || false;\n\tthis.curveType = curveType || 'centripetal';\n\tthis.tension = tension || 0.5;\n\n}\n\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar points = this.points;\n\tvar l = points.length;\n\n\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\tvar intPoint = Math.floor( p );\n\tvar weight = p - intPoint;\n\n\tif ( this.closed ) {\n\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\tintPoint = l - 2;\n\t\tweight = 1;\n\n\t}\n\n\tvar p0, p1, p2, p3; // 4 points\n\n\tif ( this.closed || intPoint > 0 ) {\n\n\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t} else {\n\n\t\t// extrapolate first point\n\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\tp0 = tmp;\n\n\t}\n\n\tp1 = points[ intPoint % l ];\n\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t} else {\n\n\t\t// extrapolate last point\n\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\tp3 = tmp;\n\n\t}\n\n\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t// init Centripetal / Chordal Catmull-Rom\n\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t// safety check for repeated points\n\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t}\n\n\tpoint.set(\n\t\tpx.calc( weight ),\n\t\tpy.calc( weight ),\n\t\tpz.calc( weight )\n\t);\n\n\treturn point;\n\n};\n\nCatmullRomCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\tvar point = source.points[ i ];\n\n\t\tthis.points.push( point.clone() );\n\n\t}\n\n\tthis.closed = source.closed;\n\tthis.curveType = source.curveType;\n\tthis.tension = source.tension;\n\n\treturn this;\n\n};\n\nCatmullRomCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.points = [];\n\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\tvar point = this.points[ i ];\n\t\tdata.points.push( point.toArray() );\n\n\t}\n\n\tdata.closed = this.closed;\n\tdata.curveType = this.curveType;\n\tdata.tension = this.tension;\n\n\treturn data;\n\n};\n\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\tvar point = json.points[ i ];\n\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t}\n\n\tthis.closed = json.closed;\n\tthis.curveType = json.curveType;\n\tthis.tension = json.tension;\n\n\treturn this;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bézier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5;\n\tvar v1 = ( p3 - p1 ) * 0.5;\n\tvar t2 = t * t;\n\tvar t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tvar k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tvar k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tvar k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CubicBezierCurve';\n\n\tthis.v0 = v0 || new Vector2();\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\tthis.v3 = v3 || new Vector2();\n\n}\n\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\tpoint.set(\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t);\n\n\treturn point;\n\n};\n\nCubicBezierCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\tthis.v3.copy( source.v3 );\n\n\treturn this;\n\n};\n\nCubicBezierCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\tdata.v3 = this.v3.toArray();\n\n\treturn data;\n\n};\n\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\tthis.v3.fromArray( json.v3 );\n\n\treturn this;\n\n};\n\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CubicBezierCurve3';\n\n\tthis.v0 = v0 || new Vector3();\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\tthis.v3 = v3 || new Vector3();\n\n}\n\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\tpoint.set(\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t);\n\n\treturn point;\n\n};\n\nCubicBezierCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\tthis.v3.copy( source.v3 );\n\n\treturn this;\n\n};\n\nCubicBezierCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\tdata.v3 = this.v3.toArray();\n\n\treturn data;\n\n};\n\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\tthis.v3.fromArray( json.v3 );\n\n\treturn this;\n\n};\n\nfunction LineCurve( v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'LineCurve';\n\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\n}\n\nLineCurve.prototype = Object.create( Curve.prototype );\nLineCurve.prototype.constructor = LineCurve;\n\nLineCurve.prototype.isLineCurve = true;\n\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tif ( t === 1 ) {\n\n\t\tpoint.copy( this.v2 );\n\n\t} else {\n\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t}\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\treturn this.getPoint( u, optionalTarget );\n\n};\n\nLineCurve.prototype.getTangent = function ( /* t */ ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\nLineCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nLineCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nLineCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction LineCurve3( v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'LineCurve3';\n\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\n}\n\nLineCurve3.prototype = Object.create( Curve.prototype );\nLineCurve3.prototype.constructor = LineCurve3;\n\nLineCurve3.prototype.isLineCurve3 = true;\n\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tif ( t === 1 ) {\n\n\t\tpoint.copy( this.v2 );\n\n\t} else {\n\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t}\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\treturn this.getPoint( u, optionalTarget );\n\n};\n\nLineCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nLineCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nLineCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'QuadraticBezierCurve';\n\n\tthis.v0 = v0 || new Vector2();\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\n}\n\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\tpoint.set(\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t);\n\n\treturn point;\n\n};\n\nQuadraticBezierCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nQuadraticBezierCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'QuadraticBezierCurve3';\n\n\tthis.v0 = v0 || new Vector3();\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\n}\n\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\tpoint.set(\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t);\n\n\treturn point;\n\n};\n\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nQuadraticBezierCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'SplineCurve';\n\n\tthis.points = points || [];\n\n}\n\nSplineCurve.prototype = Object.create( Curve.prototype );\nSplineCurve.prototype.constructor = SplineCurve;\n\nSplineCurve.prototype.isSplineCurve = true;\n\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar points = this.points;\n\tvar p = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( p );\n\tvar weight = p - intPoint;\n\n\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar p1 = points[ intPoint ];\n\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tpoint.set(\n\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t);\n\n\treturn point;\n\n};\n\nSplineCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\tvar point = source.points[ i ];\n\n\t\tthis.points.push( point.clone() );\n\n\t}\n\n\treturn this;\n\n};\n\nSplineCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.points = [];\n\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\tvar point = this.points[ i ];\n\t\tdata.points.push( point.toArray() );\n\n\t}\n\n\treturn data;\n\n};\n\nSplineCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\tvar point = json.points[ i ];\n\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t}\n\n\treturn this;\n\n};\n\n\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n\n\tCurve.call( this );\n\n\tthis.type = 'CurvePath';\n\n\tthis.curves = [];\n\tthis.autoClose = false; // Automatically closes the path\n\n}\n\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\tconstructor: CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar points = [], last;\n\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tvar curve = curves[ i ];\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n **/\n\nfunction Path( points ) {\n\n\tCurvePath.call( this );\n\n\tthis.type = 'Path';\n\n\tthis.currentPoint = new Vector2();\n\n\tif ( points ) {\n\n\t\tthis.setFromPoints( points );\n\n\t}\n\n}\n\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\tconstructor: Path,\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tvar curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurvePath.prototype.copy.call( this, source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurvePath.prototype.fromJSON.call( this, json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nfunction Shape( points ) {\n\n\tPath.call( this, points );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.type = 'Shape';\n\n\tthis.holes = [];\n\n}\n\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\n\n\tconstructor: Shape,\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tPath.prototype.copy.call( this, source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = Path.prototype.toJSON.call( this );\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tPath.prototype.fromJSON.call( this, json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Light( color, intensity ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n}\n\nLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Light,\n\n\tisLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\tLight.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new Color( groundColor );\n\n}\n\nHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: HemisphereLight,\n\n\tisHemisphereLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LightShadow( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new Matrix4();\n\n}\n\nObject.assign( LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction SpotLightShadow() {\n\n\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n}\n\nSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\tconstructor: SpotLightShadow,\n\n\tisSpotLightShadow: true,\n\n\tupdate: function ( light ) {\n\n\t\tvar camera = this.camera;\n\n\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new SpotLightShadow();\n\n}\n\nSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: SpotLight,\n\n\tisSpotLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction PointLight( color, intensity, distance, decay ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n}\n\nPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: PointLight,\n\n\tisPointLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = ( left !== undefined ) ? left : - 1;\n\tthis.right = ( right !== undefined ) ? right : 1;\n\tthis.top = ( top !== undefined ) ? top : 1;\n\tthis.bottom = ( bottom !== undefined ) ? bottom : - 1;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n}\n\nOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: OrthographicCamera,\n\n\tisOrthographicCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction DirectionalLightShadow( ) {\n\n\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n}\n\nDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\tconstructor: DirectionalLightShadow\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction DirectionalLight( color, intensity ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new Object3D();\n\n\tthis.shadow = new DirectionalLightShadow();\n\n}\n\nDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: DirectionalLight,\n\n\tisDirectionalLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AmbientLight( color, intensity ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n}\n\nAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: AmbientLight,\n\n\tisAmbientLight: true\n\n} );\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nfunction RectAreaLight( color, intensity, width, height ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'RectAreaLight';\n\n\tthis.width = ( width !== undefined ) ? width : 10;\n\tthis.height = ( height !== undefined ) ? height : 10;\n\n}\n\nRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: RectAreaLight,\n\n\tisRectAreaLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Light.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction MaterialLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\tthis.textures = {};\n\n}\n\nObject.assign( MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tvar material = new Materials[ json.type ]();\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\n\t\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\tif ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( var name in json.uniforms ) {\n\n\t\t\t\tvar uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( var key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Deprecated\n\n\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\treturn material;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar LoaderUtils = {\n\n\tdecodeText: function ( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tvar s = '';\n\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t},\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.substr( 0, index + 1 );\n\n\t}\n\n};\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedBufferGeometry() {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n}\n\nInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\n\n\tconstructor: InstancedBufferGeometry,\n\n\tisInstancedBufferGeometry: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferGeometry.prototype.copy.call( this, source );\n\n\t\tthis.maxInstancedCount = source.maxInstancedCount;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tdata.maxInstancedCount = this.maxInstancedCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {\n\n\tif ( typeof ( normalized ) === 'number' ) {\n\n\t\tmeshPerAttribute = normalized;\n\n\t\tnormalized = false;\n\n\t\tconsole.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\n\n\t}\n\n\tBufferAttribute.call( this, array, itemSize, normalized );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\n\n\tconstructor: InstancedBufferAttribute,\n\n\tisInstancedBufferAttribute: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ()\t{\n\n\t\tvar data = BufferAttribute.prototype.toJSON.call( this );\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction BufferGeometryLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\t\tvar bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\tvar bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tgeometry.addAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tvar morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( var key in morphAttributes ) {\n\n\t\t\t\tvar attributeArray = morphAttributes[ key ];\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar attribute = attributeArray[ i ];\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\t\tvar bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\nvar TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\t// Workaround for IE11 pre KB2929437. See #11440\n\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction ObjectLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\tthis.resourcePath = '';\n\n}\n\nObject.assign( ObjectLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResourcePath: function ( value ) {\n\n\t\tthis.resourcePath = value;\n\t\treturn this;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar shapes = this.parseShape( json.shapes );\n\t\tvar geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseShape: function ( json ) {\n\n\t\tvar shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t},\n\n\tparseGeometries: function ( json, shapes ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TubeGeometry':\n\t\t\t\t\tcase 'TubeBufferGeometry':\n\n\t\t\t\t\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t\t\t\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.closed\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.vertices,\n\t\t\t\t\t\t\tdata.indices,\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.details\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\tcase 'ShapeBufferGeometry':\n\n\t\t\t\t\t\tvar geometryShapes = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.curveSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\n\t\t\t\t\t\tvar geometryShapes = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\tif ( extrudePath !== undefined ) {\n\n\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.options\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tif ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {\n\n\t\t\t\t\t\t\tvar geometryLoader = new THREE.LegacyJSONLoader();\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data, this.resourcePath ).geometry;\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar cache = {}; // MultiMaterial\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\n\t\t\t\t\t// Deprecated\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var j = 0; j < data.materials.length; j ++ ) {\n\n\t\t\t\t\t\tvar material = data.materials[ j ];\n\n\t\t\t\t\t\tif ( cache[ material.uuid ] === undefined ) {\n\n\t\t\t\t\t\t\tcache[ material.uuid ] = loader.parse( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push( cache[ material.uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = array;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar data = json[ i ];\n\n\t\t\tvar clip = AnimationClip.parse( data );\n\n\t\t\tif ( data.uuid !== undefined ) clip.uuid = data.uuid;\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\tvar loader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\timages[ image.uuid ] = [];\n\n\t\t\t\t\tfor ( var j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar currentUrl = url[ j ];\n\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;\n\n\t\t\t\t\t\timages[ image.uuid ].push( loadImage( path ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( Array.isArray( images[ data.image ] ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture( images[ data.image ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = new Texture( images[ data.image ] );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function ( data, geometries, materials ) {\n\n\t\tvar object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tvar levels = data.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tvar level = levels[ l ];\n\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n} );\n\nvar TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tSphericalReflectionMapping: SphericalReflectionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\n};\n\nvar TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nvar TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n};\n\n/**\n * @author thespite / http://clicktorelease.com/\n */\n\n\nfunction ImageBitmapLoader( manager ) {\n\n\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t}\n\n\tif ( typeof fetch === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t}\n\n\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\tthis.options = undefined;\n\n}\n\nImageBitmapLoader.prototype = {\n\n\tconstructor: ImageBitmapLoader,\n\n\tsetOptions: function setOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tfetch( url ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\tif ( scope.options === undefined ) {\n\n\t\t\t\t// Workaround for FireFox. It causes an error if you pass options.\n\t\t\t\treturn createImageBitmap( blob );\n\n\t\t\t} else {\n\n\t\t\t\treturn createImageBitmap( blob, scope.options );\n\n\t\t\t}\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tscope.manager.itemStart( url );\n\n\t},\n\n\tsetCrossOrigin: function ( /* value */ ) {\n\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n **/\n\nfunction ShapePath() {\n\n\tthis.type = 'ShapePath';\n\n\tthis.color = new Color();\n\n\tthis.subPaths = [];\n\tthis.currentPath = null;\n\n}\n\nObject.assign( ShapePath.prototype, {\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t},\n\n\tsplineThru: function ( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\tvar subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction Font( data ) {\n\n\tthis.type = 'Font';\n\n\tthis.data = data;\n\n}\n\nObject.assign( Font.prototype, {\n\n\tisFont: true,\n\n\tgenerateShapes: function ( text, size ) {\n\n\t\tif ( size === undefined ) size = 100;\n\n\t\tvar shapes = [];\n\t\tvar paths = createPaths( text, size, this.data );\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\nfunction createPaths( text, size, data ) {\n\n\tvar chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988\n\tvar scale = size / data.resolution;\n\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tvar paths = [];\n\n\tvar offsetX = 0, offsetY = 0;\n\n\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\tvar char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tvar ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) return;\n\n\tvar path = new ShapePath();\n\n\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\tvar action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction FontLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new Font( json );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Loader() {}\n\nLoader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\nObject.assign( Loader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tonLoadStart: function () {},\n\n\tonLoadProgress: function () {},\n\n\tonLoadComplete: function () {},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar BlendingMode = {\n\t\t\tNoBlending: NoBlending,\n\t\t\tNormalBlending: NormalBlending,\n\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\tCustomBlending: CustomBlending\n\t\t};\n\n\t\tvar color = new Color();\n\t\tvar textureLoader = new TextureLoader();\n\t\tvar materialLoader = new MaterialLoader();\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar context;\n\nvar AudioContext = {\n\n\tgetContext: function () {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t},\n\n\tsetContext: function ( value ) {\n\n\t\tcontext = value;\n\n\t}\n\n};\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nfunction AudioLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\tvar bufferCopy = buffer.slice( 0 );\n\n\t\t\tvar context = AudioContext.getContext();\n\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nfunction SphericalHarmonics3() {\n\n\tthis.coefficients = [];\n\n\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\tthis.coefficients.push( new Vector3() );\n\n\t}\n\n}\n\nObject.assign( SphericalHarmonics3.prototype, {\n\n\tisSphericalHarmonics3: true,\n\n\tset: function ( coefficients ) {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tzero: function () {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt: function ( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tvar x = normal.x, y = normal.y, z = normal.z;\n\n\t\tvar coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScale( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScale( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScale( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScale( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScale( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScale( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScale( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScale( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t},\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt: function ( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tvar x = normal.x, y = normal.y, z = normal.z;\n\n\t\tvar coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScale( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603\n\t\ttarget.addScale( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScale( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScale( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548\n\t\ttarget.addScale( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScale( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3\n\t\ttarget.addScale( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScale( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t},\n\n\tadd: function ( sh ) {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tscale: function ( s ) {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( sh, alpha ) {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sh ) {\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcopy: function ( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tvar coefficients = this.coefficients;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, i * 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\tvar array = [];\n\t\tvar coefficients = this.coefficients;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, i * 3 );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n} );\n\nObject.assign( SphericalHarmonics3, {\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tgetBasisAt: function ( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tvar x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n} );\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * A LightProbe is a source of indirect-diffuse light\n */\n\nfunction LightProbe( sh, intensity ) {\n\n\tLight.call( this, undefined, intensity );\n\n\tthis.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();\n\n}\n\nLightProbe.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: LightProbe,\n\n\tisLightProbe: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.sh.copy( source.sh );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Light.prototype.toJSON.call( this, meta );\n\n\t\t// data.sh = this.sh.toArray(); // todo\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction HemisphereLightProbe( skyColor, groundColor, intensity ) {\n\n\tLightProbe.call( this, undefined, intensity );\n\n\tvar color1 = new Color().set( skyColor );\n\tvar color2 = new Color().set( groundColor );\n\n\tvar sky = new Vector3( color1.r, color1.g, color1.b );\n\tvar ground = new Vector3( color2.r, color2.g, color2.b );\n\n\t// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\tvar c0 = Math.sqrt( Math.PI );\n\tvar c1 = c0 * Math.sqrt( 0.75 );\n\n\tthis.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );\n\tthis.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );\n\n}\n\nHemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {\n\n\tconstructor: HemisphereLightProbe,\n\n\tisHemisphereLightProbe: true,\n\n\tcopy: function ( source ) { // modifying colors not currently supported\n\n\t\tLightProbe.prototype.copy.call( this, source );\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = LightProbe.prototype.toJSON.call( this, meta );\n\n\t\t// data.sh = this.sh.toArray(); // todo\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction AmbientLightProbe( color, intensity ) {\n\n\tLightProbe.call( this, undefined, intensity );\n\n\tvar color1 = new Color().set( color );\n\n\t// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\tthis.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );\n\n}\n\nAmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {\n\n\tconstructor: AmbientLightProbe,\n\n\tisAmbientLightProbe: true,\n\n\tcopy: function ( source ) { // modifying color not currently supported\n\n\t\tLightProbe.prototype.copy.call( this, source );\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = LightProbe.prototype.toJSON.call( this, meta );\n\n\t\t// data.sh = this.sh.toArray(); // todo\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction StereoCamera() {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.eyeSep = 0.064;\n\n\tthis.cameraL = new PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n}\n\nObject.assign( StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\n\n\t\tvar eyeRight = new Matrix4();\n\t\tvar eyeLeft = new Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tinstance = this;\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\teyeSep = this.eyeSep / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Clock( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n}\n\nObject.assign( Clock.prototype, {\n\n\tstart: function () {\n\n\t\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AudioListener() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = AudioContext.getContext();\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n\tthis.timeDelta = 0;\n\n}\n\nAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3();\n\n\t\tvar orientation = new Vector3();\n\t\tvar clock = new Clock();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.timeDelta = clock.getDelta();\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tif ( listener.positionX ) {\n\n\t\t\t\t// code path for Chrome (see #14393)\n\n\t\t\t\tvar endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\t\tlistener.positionX.linearRampToValueAtTime( position.x, endTime );\n\t\t\t\tlistener.positionY.linearRampToValueAtTime( position.y, endTime );\n\t\t\t\tlistener.positionZ.linearRampToValueAtTime( position.z, endTime );\n\t\t\t\tlistener.forwardX.linearRampToValueAtTime( orientation.x, endTime );\n\t\t\t\tlistener.forwardY.linearRampToValueAtTime( orientation.y, endTime );\n\t\t\t\tlistener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );\n\t\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t\t} else {\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t}\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nfunction Audio( listener ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.listener = listener;\n\tthis.context = listener.context;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.buffer = null;\n\tthis.detune = 0;\n\tthis.loop = false;\n\tthis.startTime = 0;\n\tthis.offset = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n}\n\nAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetMediaElementSource: function ( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tthis.startTime = this.context.currentTime;\n\t\tsource.start( this.startTime, this.offset );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\t\t\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.source.onended = null;\n\t\tthis.offset = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetDetune: function ( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.source.detune === undefined ) return; // only set detune when available\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetDetune: function () {\n\n\t\treturn this.detune;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction PositionalAudio( listener ) {\n\n\tAudio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.panningModel = 'HRTF';\n\tthis.panner.connect( this.gain );\n\n}\n\nPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\tconstructor: PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t},\n\n\tsetDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3();\n\n\t\tvar orientation = new Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\tvar panner = this.panner;\n\n\t\t\tif ( panner.positionX ) {\n\n\t\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\t\tvar endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\t\tpanner.positionX.linearRampToValueAtTime( position.x, endTime );\n\t\t\t\tpanner.positionY.linearRampToValueAtTime( position.y, endTime );\n\t\t\t\tpanner.positionZ.linearRampToValueAtTime( position.z, endTime );\n\t\t\t\tpanner.orientationX.linearRampToValueAtTime( orientation.x, endTime );\n\t\t\t\tpanner.orientationY.linearRampToValueAtTime( orientation.y, endTime );\n\t\t\t\tpanner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );\n\n\t\t\t} else {\n\n\t\t\t\tpanner.setPosition( position.x, position.y, position.z );\n\t\t\t\tpanner.setOrientation( orientation.x, orientation.y, orientation.z );\n\n\t\t\t}\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AudioAnalyser( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n}\n\nObject.assign( AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tbufferType = Array;\n\t\t\tmixFunction = this._select;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\n// Characters [].:/ are reserved for track binding syntax.\nvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\nfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n}\n\nObject.assign( Composite.prototype, {\n\n\tgetValue: function ( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function ( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function () {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function () {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n} );\n\n\nfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n}\n\nObject.assign( PropertyBinding, {\n\n\tComposite: Composite,\n\n\tcreate: function ( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tsanitizeNodeName: ( function () {\n\n\t\tvar reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );\n\n\t\treturn function sanitizeNodeName( name ) {\n\n\t\t\treturn name.replace( /\\s/g, '_' ).replace( reservedRe, '' );\n\n\t\t};\n\n\t}() ),\n\n\tparseTrackName: function () {\n\n\t\t// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t\t// instead, we exclude reserved characters and match everything else.\n\t\tvar wordChar = '[^' + RESERVED_CHARS_RE + ']';\n\t\tvar wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n\t\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t\t// be matched to parse the rest of the track name.\n\t\tvar directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar );\n\n\t\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\t\tvar nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );\n\n\t\t// Object on target node, and accessor. May not contain reserved\n\t\t// characters. Accessor may contain any character except closing bracket.\n\t\tvar objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar );\n\n\t\t// Property and accessor. May not contain reserved characters. Accessor may\n\t\t// contain any non-bracket characters.\n\t\tvar propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar );\n\n\t\tvar trackRe = new RegExp( ''\n\t\t\t+ '^'\n\t\t\t+ directoryRe\n\t\t\t+ nodeRe\n\t\t\t+ objectRe\n\t\t\t+ propertyRe\n\t\t\t+ '$'\n\t\t);\n\n\t\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\n\t\treturn function parseTrackName( trackName ) {\n\n\t\t\tvar matches = trackRe.exec( trackName );\n\n\t\t\tif ( ! matches ) {\n\n\t\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t\t}\n\n\t\t\tvar results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[ 2 ],\n\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\t\tpropertyIndex: matches[ 6 ]\n\t\t\t};\n\n\t\t\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\t\tvar objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t\t// Object names must be checked against a whitelist. Otherwise, there\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t// include '.' characters).\n\t\t\t\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\t\tresults.objectName = objectName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t\t}\n\n\t\t\treturn results;\n\n\t\t};\n\n\t}(),\n\n\tfindNode: function ( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n} );\n\nObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function () {},\n\t_setValue_unavailable: function () {},\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t],\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function () {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function () {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n} );\n\n//!\\ DECLARE ALIAS AFTER assign prototype !\nObject.assign( PropertyBinding.prototype, {\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n} );\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n *\n * @author tschw\n */\n\nfunction AnimationObjectGroup() {\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0; // threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices; // for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = []; // inside: string\n\tthis._parsedPaths = []; // inside: { we don't care, here }\n\tthis._bindings = []; // inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() {\n\n\t\t\t\treturn scope._objects.length;\n\n\t\t\t},\n\t\t\tget inUse() {\n\n\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t}\n\t\t},\n\t\tget bindingsPerObject() {\n\n\t\t\treturn scope._bindings.length;\n\n\t\t}\n\n\t};\n\n}\n\nObject.assign( AnimationObjectGroup.prototype, {\n\n\tisAnimationObjectGroup: true,\n\n\tadd: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length,\n\t\t\tknownObject = undefined;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function ( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function ( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants; // bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null; // for the memory manager\n\tthis._byClipCacheIndex = null; // for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = LoopRepeat;\n\tthis._loopCount = - 1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\tthis.paused = false; // true -> zero effective time scale\n\tthis.enabled = true; // false -> zero effective weight\n\n\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n}\n\nObject.assign( AnimationAction.prototype, {\n\n\t// State & Scheduling\n\n\tplay: function () {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function () {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function () {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function () {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function ( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function ( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function ( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function () {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function () {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function ( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function () {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function ( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function ( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function ( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function () {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function () {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function () {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function () {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function ( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function ( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function ( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\t\tvar duration = this._clip.duration;\n\t\tvar loop = this.loop;\n\t\tvar loopCount = this._loopCount;\n\n\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Uniform( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n}\n\nUniform.prototype.clone = function () {\n\n\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n};\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\tInterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\n\n\tconstructor: InstancedInterleavedBuffer,\n\n\tisInstancedInterleavedBuffer: true,\n\n\tcopy: function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\nfunction Raycaster( origin, direction, near, far ) {\n\n\tthis.ray = new Ray( origin, direction );\n\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\tthis.near = near || 0;\n\tthis.far = far || Infinity;\n\n\tthis.params = {\n\t\tMesh: {},\n\t\tLine: {},\n\t\tLOD: {},\n\t\tPoints: { threshold: 1 },\n\t\tSprite: {}\n\t};\n\n\tObject.defineProperties( this.params, {\n\t\tPointCloud: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\treturn this.Points;\n\n\t\t\t}\n\t\t}\n\t} );\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.visible === false ) return;\n\n\tobject.raycast( raycaster, intersects );\n\n\tif ( recursive === true ) {\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Raycaster.prototype, {\n\n\tlinePrecision: 1,\n\n\tset: function ( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t},\n\n\tsetFromCamera: function ( coords, camera ) {\n\n\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis._camera = camera;\n\n\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis._camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t}\n\n\t},\n\n\tintersectObject: function ( object, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t},\n\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axiz.\n */\n\nfunction Spherical( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // polar angle\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle\n\n\treturn this;\n\n}\n\nObject.assign( Spherical.prototype, {\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function () {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function ( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t},\n\n\tsetFromCartesianCoords: function ( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n *\n */\n\nfunction Cylindrical( radius, theta, y ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\n\n\treturn this;\n\n}\n\nObject.assign( Cylindrical.prototype, {\n\n\tset: function ( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function ( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t},\n\n\tsetFromCartesianCoords: function ( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Box2( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n}\n\nObject.assign( Box2.prototype, {\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getCenter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tgetSize: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getSize() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t},\n\n\tgetParameter: function ( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getParameter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t},\n\n\tclampPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Line3( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n}\n\nObject.assign( Line3.prototype, {\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .delta() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new Vector3();\n\t\tvar startEnd = new Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, target ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction ImmediateRenderObject( material ) {\n\n\tObject3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( /* renderCallback */ ) {};\n\n}\n\nImmediateRenderObject.prototype = Object.create( Object3D.prototype );\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n}\n\nVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar normalMatrix = new Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t};\n\n}() );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction SpotLightHelper( light, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0, \t0, 0, 1,\n\t\t0, 0, 0, \t1, 0, 1,\n\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t0, 0, 0, \t0, 1, 1,\n\t\t0, 0, 0, \t0, - 1, 1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n}\n\nSpotLightHelper.prototype = Object.create( Object3D.prototype );\nSpotLightHelper.prototype.constructor = SpotLightHelper;\n\nSpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nSpotLightHelper.prototype.update = function () {\n\n\tvar vector = new Vector3();\n\n\treturn function update() {\n\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t};\n\n}();\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction getBoneList( object ) {\n\n\tvar boneList = [];\n\n\tif ( object && object.isBone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nfunction SkeletonHelper( object ) {\n\n\tvar bones = getBoneList( object );\n\n\tvar geometry = new BufferGeometry();\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar color1 = new Color( 0, 0, 1 );\n\tvar color2 = new Color( 0, 1, 0 );\n\n\tfor ( var i = 0; i < bones.length; i ++ ) {\n\n\t\tvar bone = bones[ i ];\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t}\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tLineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\tthis.bones = bones;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n}\n\nSkeletonHelper.prototype = Object.create( LineSegments.prototype );\nSkeletonHelper.prototype.constructor = SkeletonHelper;\n\nSkeletonHelper.prototype.updateMatrixWorld = function () {\n\n\tvar vector = new Vector3();\n\n\tvar boneMatrix = new Matrix4();\n\tvar matrixWorldInv = new Matrix4();\n\n\treturn function updateMatrixWorld( force ) {\n\n\t\tvar bones = this.bones;\n\n\t\tvar geometry = this.geometry;\n\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\tmatrixWorldInv.getInverse( this.root.matrixWorld );\n\n\t\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\tposition.setXYZ( j, vector.x, vector.y, vector.z );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction PointLightHelper( light, sphereSize, color ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.color = color;\n\n\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n}\n\nPointLightHelper.prototype = Object.create( Mesh.prototype );\nPointLightHelper.prototype.constructor = PointLightHelper;\n\nPointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nPointLightHelper.prototype.update = function () {\n\n\tif ( this.color !== undefined ) {\n\n\t\tthis.material.color.set( this.color );\n\n\t} else {\n\n\t\tthis.material.color.copy( this.light.color );\n\n\t}\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n/**\n * @author abelnation / http://github.com/abelnation\n * @author Mugen87 / http://github.com/Mugen87\n * @author WestLangley / http://github.com/WestLangley\n *\n *  This helper must be added as a child of the light\n */\n\nfunction RectAreaLightHelper( light, color ) {\n\n\tthis.type = 'RectAreaLightHelper';\n\n\tthis.light = light;\n\n\tthis.color = color; // optional hardwired color for the helper\n\n\tvar positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tgeometry.computeBoundingSphere();\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tLine.call( this, geometry, material );\n\n\t//\n\n\tvar positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\tvar geometry2 = new BufferGeometry();\n\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\tgeometry2.computeBoundingSphere();\n\n\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );\n\n\tthis.update();\n\n}\n\nRectAreaLightHelper.prototype = Object.create( Line.prototype );\nRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\n\nRectAreaLightHelper.prototype.update = function () {\n\n\tthis.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );\n\n\tif ( this.color !== undefined ) {\n\n\t\tthis.material.color.set( this.color );\n\t\tthis.children[ 0 ].material.color.set( this.color );\n\n\t} else {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t// prevent hue shift\n\t\tvar c = this.material.color;\n\t\tvar max = Math.max( c.r, c.g, c.b );\n\t\tif ( max > 1 ) c.multiplyScalar( 1 / max );\n\n\t\tthis.children[ 0 ].material.color.copy( this.material.color );\n\n\t}\n\n};\n\nRectAreaLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\tthis.children[ 0 ].geometry.dispose();\n\tthis.children[ 0 ].material.dispose();\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction HemisphereLightHelper( light, size, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tvar geometry = new OctahedronBufferGeometry( size );\n\tgeometry.rotateY( Math.PI * 0.5 );\n\n\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\n\n\tvar position = geometry.getAttribute( 'position' );\n\tvar colors = new Float32Array( position.count * 3 );\n\n\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\tthis.add( new Mesh( geometry, this.material ) );\n\n\tthis.update();\n\n}\n\nHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\nHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\nHemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.children[ 0 ].geometry.dispose();\n\tthis.children[ 0 ].material.dispose();\n\n};\n\nHemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new Vector3();\n\n\tvar color1 = new Color();\n\tvar color2 = new Color();\n\n\treturn function update() {\n\n\t\tvar mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tvar colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\tcolor1.copy( this.light.color );\n\t\t\tcolor2.copy( this.light.groundColor );\n\n\t\t\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t};\n\n}();\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction LightProbeHelper( lightProbe, size ) {\n\n\tthis.lightProbe = lightProbe;\n\n\tthis.size = size;\n\n\tvar defines = {};\n\tdefines[ 'GAMMA_OUTPUT' ] = \"\";\n\n\t// material\n\tvar material = new ShaderMaterial( {\n\n\t\tdefines: defines,\n\n\t\tuniforms: {\n\n\t\t\tsh: { value: this.lightProbe.sh.coefficients }, // by reference\n\n\t\t\tintensity: { value: this.lightProbe.intensity }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'varying vec3 vNormal;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvNormal = normalize( normalMatrix * normal );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}',\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'#define RECIPROCAL_PI 0.318309886',\n\n\t\t\t'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',\n\n\t\t\t'\t// matrix is assumed to be orthogonal',\n\n\t\t\t'\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 linearToOutput( in vec3 a ) {',\n\n\t\t\t'\t#ifdef GAMMA_OUTPUT',\n\n\t\t\t'\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\treturn a;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'}',\n\n\t\t\t'// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',\n\t\t\t'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',\n\n\t\t\t'\t// normal is assumed to have unit length',\n\n\t\t\t'\tfloat x = normal.x, y = normal.y, z = normal.z;',\n\n\t\t\t'\t// band 0',\n\t\t\t'\tvec3 result = shCoefficients[ 0 ] * 0.886227;',\n\n\t\t\t'\t// band 1',\n\t\t\t'\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',\n\t\t\t'\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',\n\t\t\t'\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',\n\n\t\t\t'\t// band 2',\n\t\t\t'\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',\n\t\t\t'\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',\n\t\t\t'\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',\n\t\t\t'\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',\n\t\t\t'\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',\n\n\t\t\t'\treturn result;',\n\n\t\t\t'}',\n\n\t\t\t'uniform vec3 sh[ 9 ]; // sh coefficients',\n\n\t\t\t'uniform float intensity; // light probe intensity',\n\n\t\t\t'varying vec3 vNormal;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec3 normal = normalize( vNormal );',\n\n\t\t\t'\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',\n\n\t\t\t'\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );',\n\n\t\t\t'\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',\n\n\t\t\t'\toutgoingLight = linearToOutput( outgoingLight );',\n\n\t\t\t'\tgl_FragColor = vec4( outgoingLight, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\n\t} );\n\n\tvar geometry = new SphereBufferGeometry( 1, 32, 16 );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.onBeforeRender();\n\n}\n\nLightProbeHelper.prototype = Object.create( Mesh.prototype );\nLightProbeHelper.prototype.constructor = LightProbeHelper;\n\nLightProbeHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nLightProbeHelper.prototype.onBeforeRender = function () {\n\n\treturn function update() {\n\n\t\tthis.position.copy( this.lightProbe.position );\n\n\t\tthis.scale.set( 1, 1, 1 ).multiplyScalar( this.size );\n\n\t\tthis.material.uniforms.intensity.value = this.lightProbe.intensity;\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction GridHelper( size, divisions, color1, color2 ) {\n\n\tsize = size || 10;\n\tdivisions = divisions || 10;\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar center = divisions / 2;\n\tvar step = size / divisions;\n\tvar halfSize = size / 2;\n\n\tvar vertices = [], colors = [];\n\n\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\tvar color = i === center ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nGridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {\n\n\tconstructor: GridHelper,\n\n\tcopy: function ( source ) {\n\n\t\tLineSegments.prototype.copy.call( this, source );\n\n\t\tthis.geometry.copy( source.geometry );\n\t\tthis.material.copy( source.material );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author Hectate / http://www.github.com/Hectate\n */\n\nfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\n\n\tradius = radius || 10;\n\tradials = radials || 16;\n\tcircles = circles || 8;\n\tdivisions = divisions || 64;\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar x, z;\n\tvar v, i, j, r, color;\n\n\t// create the radials\n\n\tfor ( i = 0; i <= radials; i ++ ) {\n\n\t\tv = ( i / radials ) * ( Math.PI * 2 );\n\n\t\tx = Math.sin( v ) * radius;\n\t\tz = Math.cos( v ) * radius;\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tvertices.push( x, 0, z );\n\n\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\tcolors.push( color.r, color.g, color.b );\n\t\tcolors.push( color.r, color.g, color.b );\n\n\t}\n\n\t// create the circles\n\n\tfor ( i = 0; i <= circles; i ++ ) {\n\n\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\tr = radius - ( radius / circles * i );\n\n\t\tfor ( j = 0; j < divisions; j ++ ) {\n\n\t\t\t// first vertex\n\n\t\t\tv = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\tx = Math.sin( v ) * r;\n\t\t\tz = Math.cos( v ) * r;\n\n\t\t\tvertices.push( x, 0, z );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t// second vertex\n\n\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\tx = Math.sin( v ) * r;\n\t\t\tz = Math.cos( v ) * r;\n\n\t\t\tvertices.push( x, 0, z );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t}\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nPolarGridHelper.prototype = Object.create( LineSegments.prototype );\nPolarGridHelper.prototype.constructor = PolarGridHelper;\n\n/**\n * @author Mugen87 / http://github.com/Mugen87\n */\n\nfunction PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {\n\n\tthis.audio = audio;\n\tthis.range = range || 1;\n\tthis.divisionsInnerAngle = divisionsInnerAngle || 16;\n\tthis.divisionsOuterAngle = divisionsOuterAngle || 2;\n\n\tvar geometry = new BufferGeometry();\n\tvar divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;\n\tvar positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );\n\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tvar materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );\n\tvar materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );\n\n\tLine.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );\n\n\tthis.update();\n\n}\n\nPositionalAudioHelper.prototype = Object.create( Line.prototype );\nPositionalAudioHelper.prototype.constructor = PositionalAudioHelper;\n\nPositionalAudioHelper.prototype.update = function () {\n\n\tvar audio = this.audio;\n\tvar range = this.range;\n\tvar divisionsInnerAngle = this.divisionsInnerAngle;\n\tvar divisionsOuterAngle = this.divisionsOuterAngle;\n\n\tvar coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );\n\tvar coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );\n\n\tvar halfConeInnerAngle = coneInnerAngle / 2;\n\tvar halfConeOuterAngle = coneOuterAngle / 2;\n\n\tvar start = 0;\n\tvar count = 0;\n\tvar i, stride;\n\n\tvar geometry = this.geometry;\n\tvar positionAttribute = geometry.attributes.position;\n\n\tgeometry.clearGroups();\n\n\t//\n\n\tfunction generateSegment( from, to, divisions, materialIndex ) {\n\n\t\tvar step = ( to - from ) / divisions;\n\n\t\tpositionAttribute.setXYZ( start, 0, 0, 0 );\n\t\tcount ++;\n\n\t\tfor ( i = from; i < to; i += step ) {\n\n\t\t\tstride = start + count;\n\n\t\t\tpositionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );\n\t\t\tpositionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );\n\t\t\tpositionAttribute.setXYZ( stride + 2, 0, 0, 0 );\n\n\t\t\tcount += 3;\n\n\t\t}\n\n\t\tgeometry.addGroup( start, count, materialIndex );\n\n\t\tstart += count;\n\t\tcount = 0;\n\n\t}\n\n\t//\n\n\tgenerateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );\n\tgenerateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );\n\tgenerateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );\n\n\t//\n\n\tpositionAttribute.needsUpdate = true;\n\n\tif ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;\n\n};\n\nPositionalAudioHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material[ 0 ].dispose();\n\tthis.material[ 1 ].dispose();\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n}\n\nFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\nFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\nFaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar normalMatrix = new Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t};\n\n}() );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction DirectionalLightHelper( light, size, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\n\t\t- size, size, 0,\n\t\tsize, size, 0,\n\t\tsize, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size, size, 0\n\t], 3 ) );\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tthis.lightPlane = new Line( geometry, material );\n\tthis.add( this.lightPlane );\n\n\tgeometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.targetLine = new Line( geometry, material );\n\tthis.add( this.targetLine );\n\n\tthis.update();\n\n}\n\nDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\nDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\nDirectionalLightHelper.prototype.dispose = function () {\n\n\tthis.lightPlane.geometry.dispose();\n\tthis.lightPlane.material.dispose();\n\tthis.targetLine.geometry.dispose();\n\tthis.targetLine.material.dispose();\n\n};\n\nDirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar v3 = new Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tthis.lightPlane.lookAt( v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( v2 );\n\t\tthis.targetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author Mugen87 / https://github.com/Mugen87\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nfunction CameraHelper( camera ) {\n\n\tvar geometry = new BufferGeometry();\n\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar colorFrustum = new Color( 0xffaa00 );\n\tvar colorCone = new Color( 0xff0000 );\n\tvar colorUp = new Color( 0x00aaff );\n\tvar colorTarget = new Color( 0xffffff );\n\tvar colorCross = new Color( 0x333333 );\n\n\t// near\n\n\taddLine( 'n1', 'n2', colorFrustum );\n\taddLine( 'n2', 'n4', colorFrustum );\n\taddLine( 'n4', 'n3', colorFrustum );\n\taddLine( 'n3', 'n1', colorFrustum );\n\n\t// far\n\n\taddLine( 'f1', 'f2', colorFrustum );\n\taddLine( 'f2', 'f4', colorFrustum );\n\taddLine( 'f4', 'f3', colorFrustum );\n\taddLine( 'f3', 'f1', colorFrustum );\n\n\t// sides\n\n\taddLine( 'n1', 'f1', colorFrustum );\n\taddLine( 'n2', 'f2', colorFrustum );\n\taddLine( 'n3', 'f3', colorFrustum );\n\taddLine( 'n4', 'f4', colorFrustum );\n\n\t// cone\n\n\taddLine( 'p', 'n1', colorCone );\n\taddLine( 'p', 'n2', colorCone );\n\taddLine( 'p', 'n3', colorCone );\n\taddLine( 'p', 'n4', colorCone );\n\n\t// up\n\n\taddLine( 'u1', 'u2', colorUp );\n\taddLine( 'u2', 'u3', colorUp );\n\taddLine( 'u3', 'u1', colorUp );\n\n\t// target\n\n\taddLine( 'c', 't', colorTarget );\n\taddLine( 'p', 'c', colorCross );\n\n\t// cross\n\n\taddLine( 'cn1', 'cn2', colorCross );\n\taddLine( 'cn3', 'cn4', colorCross );\n\n\taddLine( 'cf1', 'cf2', colorCross );\n\taddLine( 'cf3', 'cf4', colorCross );\n\n\tfunction addLine( a, b, color ) {\n\n\t\taddPoint( a, color );\n\t\taddPoint( b, color );\n\n\t}\n\n\tfunction addPoint( id, color ) {\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tcolors.push( color.r, color.g, color.b );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tLineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n}\n\nCameraHelper.prototype = Object.create( LineSegments.prototype );\nCameraHelper.prototype.constructor = CameraHelper;\n\nCameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new Vector3();\n\tvar camera = new Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', 0, 0, - 1 );\n\t\tsetPoint( 't', 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', - w, - h, - 1 );\n\t\tsetPoint( 'n2', w, - h, - 1 );\n\t\tsetPoint( 'n3', - w, h, - 1 );\n\t\tsetPoint( 'n4', w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', - w, - h, 1 );\n\t\tsetPoint( 'f2', w, - h, 1 );\n\t\tsetPoint( 'f3', - w, h, 1 );\n\t\tsetPoint( 'f4', w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', - w, 0, 1 );\n\t\tsetPoint( 'cf2', w, 0, 1 );\n\t\tsetPoint( 'cf3', 0, - h, 1 );\n\t\tsetPoint( 'cf4', 0, h, 1 );\n\n\t\tsetPoint( 'cn1', - w, 0, - 1 );\n\t\tsetPoint( 'cn2', w, 0, - 1 );\n\t\tsetPoint( 'cn3', 0, - h, - 1 );\n\t\tsetPoint( 'cn4', 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n */\n\nfunction BoxHelper( object, color ) {\n\n\tthis.object = object;\n\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n}\n\nBoxHelper.prototype = Object.create( LineSegments.prototype );\nBoxHelper.prototype.constructor = BoxHelper;\n\nBoxHelper.prototype.update = ( function () {\n\n\tvar box = new Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\tbox.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\nBoxHelper.prototype.setFromObject = function ( object ) {\n\n\tthis.object = object;\n\tthis.update();\n\n\treturn this;\n\n};\n\nBoxHelper.prototype.copy = function ( source ) {\n\n\tLineSegments.prototype.copy.call( this, source );\n\n\tthis.object = source.object;\n\n\treturn this;\n\n};\n\nBoxHelper.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Box3Helper( box, color ) {\n\n\tthis.type = 'Box3Helper';\n\n\tthis.box = box;\n\n\tcolor = color || 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\tvar geometry = new BufferGeometry();\n\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\tthis.geometry.computeBoundingSphere();\n\n}\n\nBox3Helper.prototype = Object.create( LineSegments.prototype );\nBox3Helper.prototype.constructor = Box3Helper;\n\nBox3Helper.prototype.updateMatrixWorld = function ( force ) {\n\n\tvar box = this.box;\n\n\tif ( box.isEmpty() ) return;\n\n\tbox.getCenter( this.position );\n\n\tbox.getSize( this.scale );\n\n\tthis.scale.multiplyScalar( 0.5 );\n\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction PlaneHelper( plane, size, hex ) {\n\n\tthis.type = 'PlaneHelper';\n\n\tthis.plane = plane;\n\n\tthis.size = ( size === undefined ) ? 1 : size;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tgeometry.computeBoundingSphere();\n\n\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t//\n\n\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\n\tvar geometry2 = new BufferGeometry();\n\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\tgeometry2.computeBoundingSphere();\n\n\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\n\n}\n\nPlaneHelper.prototype = Object.create( Line.prototype );\nPlaneHelper.prototype.constructor = PlaneHelper;\n\nPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\n\n\tvar scale = - this.plane.constant;\n\n\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\n\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\n\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\tthis.lookAt( this.plane.normal );\n\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nvar lineGeometry, coneGeometry;\n\nfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t// dir is assumed to be normalized\n\n\tObject3D.call( this );\n\n\tif ( dir === undefined ) dir = new Vector3( 0, 0, 1 );\n\tif ( origin === undefined ) origin = new Vector3( 0, 0, 0 );\n\tif ( length === undefined ) length = 1;\n\tif ( color === undefined ) color = 0xffff00;\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tif ( lineGeometry === undefined ) {\n\n\t\tlineGeometry = new BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\t}\n\n\tthis.position.copy( origin );\n\n\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\tthis.line.matrixAutoUpdate = false;\n\tthis.add( this.line );\n\n\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\tthis.cone.matrixAutoUpdate = false;\n\tthis.add( this.cone );\n\n\tthis.setDirection( dir );\n\tthis.setLength( length, headLength, headWidth );\n\n}\n\nArrowHelper.prototype = Object.create( Object3D.prototype );\nArrowHelper.prototype.constructor = ArrowHelper;\n\nArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.set( color );\n\tthis.cone.material.color.set( color );\n\n};\n\nArrowHelper.prototype.copy = function ( source ) {\n\n\tObject3D.prototype.copy.call( this, source, false );\n\n\tthis.line.copy( source.line );\n\tthis.cone.copy( source.cone );\n\n\treturn this;\n\n};\n\nArrowHelper.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AxesHelper( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = [\n\t\t0, 0, 0,\tsize, 0, 0,\n\t\t0, 0, 0,\t0, size, 0,\n\t\t0, 0, 0,\t0, 0, size\n\t];\n\n\tvar colors = [\n\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t0, 0, 1,\t0, 0.6, 1\n\t];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nAxesHelper.prototype = Object.create( LineSegments.prototype );\nAxesHelper.prototype.constructor = AxesHelper;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Face4( a, b, c, d, normal, color, materialIndex ) {\n\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\treturn new Face3( a, b, c, normal, color, materialIndex );\n\n}\n\nvar LineStrip = 0;\n\nvar LinePieces = 1;\n\nfunction MeshFaceMaterial( materials ) {\n\n\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\treturn materials;\n\n}\n\nfunction MultiMaterial( materials ) {\n\n\tif ( materials === undefined ) materials = [];\n\n\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\tmaterials.isMultiMaterial = true;\n\tmaterials.materials = materials;\n\tmaterials.clone = function () {\n\n\t\treturn materials.slice();\n\n\t};\n\treturn materials;\n\n}\n\nfunction PointCloud( geometry, material ) {\n\n\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction Particle( material ) {\n\n\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\treturn new Sprite( material );\n\n}\n\nfunction ParticleSystem( geometry, material ) {\n\n\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction PointCloudMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleBasicMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleSystemMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction Vertex( x, y, z ) {\n\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\treturn new Vector3( x, y, z );\n\n}\n\n//\n\nfunction DynamicBufferAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n}\n\nfunction Int8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\treturn new Int8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\treturn new Uint8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\n}\n\nfunction Int16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\treturn new Int16BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\treturn new Uint16BufferAttribute( array, itemSize );\n\n}\n\nfunction Int32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\treturn new Int32BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\treturn new Uint32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\treturn new Float32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float64Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\treturn new Float64BufferAttribute( array, itemSize );\n\n}\n\n//\n\nCurve.create = function ( construct, getPoint ) {\n\n\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\n\tconstruct.prototype = Object.create( Curve.prototype );\n\tconstruct.prototype.constructor = construct;\n\tconstruct.prototype.getPoint = getPoint;\n\n\treturn construct;\n\n};\n\n//\n\nObject.assign( CurvePath.prototype, {\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t// generate geometry from path points (for Line or Points objects)\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t// generate geometry from equidistant sampling along the path\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n//\n\nObject.assign( Path.prototype, {\n\n\tfromPoints: function ( points ) {\n\n\t\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\t\tthis.setFromPoints( points );\n\n\t}\n\n} );\n\n//\n\nfunction ClosedSplineCurve3( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n}\n\nClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n//\n\nfunction SplineCurve3( points ) {\n\n\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\n}\n\nSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n//\n\nfunction Spline( points ) {\n\n\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\n}\n\nSpline.prototype = Object.create( CatmullRomCurve3.prototype );\n\nObject.assign( Spline.prototype, {\n\n\tinitFromArray: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\n\n\t},\n\tgetControlPointsArray: function ( /* optionalTarget */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\n\n\t},\n\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\n\n\t}\n\n} );\n\n//\n\nfunction AxisHelper( size ) {\n\n\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\treturn new AxesHelper( size );\n\n}\n\nfunction BoundingBoxHelper( object, color ) {\n\n\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\treturn new BoxHelper( object, color );\n\n}\n\nfunction EdgesHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\nGridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\nSkeletonHelper.prototype.update = function () {\n\n\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\n};\n\nfunction WireframeHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\n//\n\nObject.assign( Loader.prototype, {\n\n\textractUrlBase: function ( url ) {\n\n\t\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\t\treturn LoaderUtils.extractUrlBase( url );\n\n\t}\n\n} );\n\nfunction XHRLoader( manager ) {\n\n\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\treturn new FileLoader( manager );\n\n}\n\nfunction BinaryTextureLoader( manager ) {\n\n\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\treturn new DataTextureLoader( manager );\n\n}\n\nObject.assign( ObjectLoader.prototype, {\n\n\tsetTexturePath: function ( value ) {\n\n\t\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\n\t\treturn this.setResourcePath( value );\n\n\t}\n\n} );\n\n//\n\nObject.assign( Box2.prototype, {\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\treturn this.getCenter( optionalTarget );\n\n\t},\n\tempty: function () {\n\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\n\t},\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tsize: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\treturn this.getSize( optionalTarget );\n\n\t}\n} );\n\nObject.assign( Box3.prototype, {\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\treturn this.getCenter( optionalTarget );\n\n\t},\n\tempty: function () {\n\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\n\t},\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\n\t},\n\tsize: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\treturn this.getSize( optionalTarget );\n\n\t}\n} );\n\nLine3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nObject.assign( _Math, {\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\n\t\treturn _Math.floorPowerOfTwo( value );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\n\t\treturn _Math.ceilPowerOfTwo( value );\n\n\t}\n\n} );\n\nObject.assign( Matrix3.prototype, {\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\treturn this.toArray( array, offset );\n\n\t},\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\n\t},\n\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\n\t},\n\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\treturn this.applyToBufferAttribute( buffer );\n\n\t},\n\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n\t}\n\n} );\n\nObject.assign( Matrix4.prototype, {\n\n\textractPosition: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\n\t},\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\treturn this.toArray( array, offset );\n\n\t},\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\n\t},\n\tmultiplyToArray: function () {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\n\t},\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\tmultiplyVector4: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\n\t},\n\trotateAxis: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\n\t},\n\tcrossVector: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\ttranslate: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n\t},\n\trotateX: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n\t},\n\trotateY: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n\t},\n\trotateZ: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n\t},\n\trotateByAxis: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n\t},\n\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\treturn this.applyToBufferAttribute( buffer );\n\n\t},\n\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n\t},\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\t\treturn this.makePerspective( left, right, top, bottom, near, far );\n\n\t}\n\n} );\n\nPlane.prototype.isIntersectionLine = function ( line ) {\n\n\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\treturn this.intersectsLine( line );\n\n};\n\nQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\treturn vector.applyQuaternion( this );\n\n};\n\nObject.assign( Ray.prototype, {\n\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\n\t}\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tarea: function () {\n\n\t\tconsole.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );\n\t\treturn this.getArea();\n\n\t},\n\tbarycoordFromPoint: function ( point, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\t\treturn this.getBarycoord( point, target );\n\n\t},\n\tmidpoint: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );\n\t\treturn this.getMidpoint( target );\n\n\t},\n\tnormal: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\t\treturn this.getNormal( target );\n\n\t},\n\tplane: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );\n\t\treturn this.getPlane( target );\n\n\t}\n\n} );\n\nObject.assign( Triangle, {\n\n\tbarycoordFromPoint: function ( point, a, b, c, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\t\treturn Triangle.getBarycoord( point, a, b, c, target );\n\n\t},\n\tnormal: function ( a, b, c, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\t\treturn Triangle.getNormal( a, b, c, target );\n\n\t}\n\n} );\n\nObject.assign( Shape.prototype, {\n\n\textractAllPoints: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\t\treturn this.extractPoints( divisions );\n\n\t},\n\textrude: function ( options ) {\n\n\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\treturn new ExtrudeGeometry( this, options );\n\n\t},\n\tmakeGeometry: function ( options ) {\n\n\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\treturn new ShapeGeometry( this, options );\n\n\t}\n\n} );\n\nObject.assign( Vector2.prototype, {\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tdistanceToManhattan: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\treturn this.manhattanDistanceTo( v );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\nObject.assign( Vector3.prototype, {\n\n\tsetEulerFromRotationMatrix: function () {\n\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n\t},\n\tsetEulerFromQuaternion: function () {\n\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\n\t},\n\tapplyProjection: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\t\treturn this.applyMatrix4( m );\n\n\t},\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tdistanceToManhattan: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\treturn this.manhattanDistanceTo( v );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\nObject.assign( Vector4.prototype, {\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\n//\n\nObject.assign( Geometry.prototype, {\n\n\tcomputeTangents: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\tcomputeLineDistances: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t}\n\n} );\n\nObject.assign( Object3D.prototype, {\n\n\tgetChildByName: function ( name ) {\n\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\n\t},\n\trenderDepth: function () {\n\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n\t},\n\ttranslate: function ( distance, axis ) {\n\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\n\t},\n\tgetWorldRotation: function () {\n\n\t\tconsole.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );\n\n\t}\n\n} );\n\nObject.defineProperties( Object3D.prototype, {\n\n\teulerOrder: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( LOD.prototype, {\n\n\tobjects: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\n\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t},\n\tset: function () {\n\n\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t}\n\n} );\n\nSkinnedMesh.prototype.initBones = function () {\n\n\tconsole.error( 'THREE.SkinnedMesh: initBones() has been removed.' );\n\n};\n\nObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\n\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\treturn this.arcLengthDivisions;\n\n\t},\n\tset: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\tthis.arcLengthDivisions = value;\n\n\t}\n\n} );\n\n//\n\nPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( Light.prototype, {\n\tonlyShadow: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( BufferAttribute.prototype, {\n\n\tlength: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\treturn this.array.length;\n\n\t\t}\n\t},\n\tcopyIndicesArray: function ( /* indices */ ) {\n\n\t\tconsole.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );\n\n\t}\n\n} );\n\nObject.assign( BufferGeometry.prototype, {\n\n\taddIndex: function ( index ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\n\t\tif ( indexOffset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\n\t},\n\tclearDrawCalls: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\n\t},\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\n\t},\n\tcomputeOffsets: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n\t}\n\n} );\n\nObject.defineProperties( BufferGeometry.prototype, {\n\n\tdrawcalls: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.assign( ExtrudeBufferGeometry.prototype, {\n\n\tgetArrays: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );\n\n\t},\n\n\taddShapeList: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );\n\n\t},\n\n\taddShape: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );\n\n\t}\n\n} );\n\n//\n\nObject.defineProperties( Uniform.prototype, {\n\n\tdynamic: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\n\t\t}\n\t},\n\tonUpdate: {\n\t\tvalue: function () {\n\n\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\treturn this;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( Material.prototype, {\n\n\twrapAround: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t}\n\t},\n\n\toverdraw: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t}\n\t},\n\n\twrapRGB: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\treturn new Color();\n\n\t\t}\n\t},\n\n\tshading: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\tthis.flatShading = ( value === FlatShading );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( MeshPhongMaterial.prototype, {\n\n\tmetal: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( ShaderMaterial.prototype, {\n\n\tderivatives: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.assign( WebGLRenderer.prototype, {\n\n\tclearTarget: function ( renderTarget, color, depth, stencil ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t},\n\tanimate: function ( callback ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );\n\t\tthis.setAnimationLoop( callback );\n\n\t},\n\tgetCurrentRenderTarget: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\t\treturn this.getRenderTarget();\n\n\t},\n\tgetMaxAnisotropy: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t},\n\tgetPrecision: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\t\treturn this.capabilities.precision;\n\n\t},\n\tresetGLState: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\t\treturn this.state.reset();\n\n\t},\n\tsupportsFloatTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\n\t},\n\tsupportsHalfFloatTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\n\t},\n\tsupportsStandardDerivatives: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t},\n\tsupportsBlendMinMax: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\n\t},\n\tsupportsVertexTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\t\treturn this.capabilities.vertexTextures;\n\n\t},\n\tsupportsInstancedArrays: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\n\t},\n\tenableScissorTest: function ( boolean ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\n\t},\n\tinitMaterial: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n\t},\n\taddPrePlugin: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n\t},\n\taddPostPlugin: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n\t},\n\tupdateShadowMap: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n\t},\n\tsetFaceCulling: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\n\t},\n\tallocTextureUnit: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );\n\n\t},\n\tsetTexture: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );\n\n\t},\n\tsetTexture2D: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );\n\n\t},\n\tsetTextureCube: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );\n\n\t}\n\n} );\n\nObject.defineProperties( WebGLRenderer.prototype, {\n\n\tshadowMapEnabled: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.enabled;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n} );\n\nObject.defineProperties( WebGLShadowMap.prototype, {\n\n\tcullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* cullFace */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderReverseSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderSingleSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( WebGLRenderTargetCube.prototype, {\n\n\tactiveCubeFace: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().' );\n\n\t\t}\n\t},\n\tactiveMipMapLevel: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().' );\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( WebGLRenderTarget.prototype, {\n\n\twrapS: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( WebVRManager.prototype, {\n\n\tstanding: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\n\n\t\t}\n\t},\n\tuserHeight: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebVRManager: .userHeight has been removed.' );\n\n\t\t}\n\t}\n\n} );\n\n//\n\nAudio.prototype.load = function ( file ) {\n\n\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\tvar scope = this;\n\tvar audioLoader = new AudioLoader();\n\taudioLoader.load( file, function ( buffer ) {\n\n\t\tscope.setBuffer( buffer );\n\n\t} );\n\treturn this;\n\n};\n\nAudioAnalyser.prototype.getData = function () {\n\n\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\treturn this.getFrequencyData();\n\n};\n\n//\n\nCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\treturn this.update( renderer, scene );\n\n};\n\n//\n\nvar GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\tvar matrix;\n\n\t\tif ( geometry2.isMesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\tvar loader = new TextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\tvar loader = new CubeTextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadCompressedTexture = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\n//\n\nfunction CanvasRenderer() {\n\n\tconsole.error( 'THREE.CanvasRenderer has been removed' );\n\n}\n\n//\n\nfunction JSONLoader() {\n\n\tconsole.error( 'THREE.JSONLoader has been removed.' );\n\n}\n\n//\n\nvar SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t},\n\n\tdetach: function ( /* child, parent, scene */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t},\n\n\tattach: function ( /* child, scene, parent */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t}\n\n};\n\n//\n\nfunction LensFlare() {\n\n\tconsole.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );\n\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/three/build/three.module.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _skybox_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./skybox.png */ \"./src/skybox.png\");\n/* harmony import */ var _skybox_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_skybox_png__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar AROrientationControls = __webpack_require__(/*! three-arorientationcontrols */ \"./node_modules/three-arorientationcontrols/AROrientationControls.js\");\n\nvar scene = new THREE.Scene();\nvar camera = new THREE.PerspectiveCamera(67, window.innerWidth / window.innerHeight, 0.001, 1000);\nvar renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.shadowMap.enabled = true;\ndocument.body.appendChild(renderer.domElement);\nvar controls = new THREE.AROrientationControls(camera, scene, renderer.domElement, {\n  mode: 'ar',\n  failSafe: true,\n  success: function success(mode) {\n    if (mode == 'vr') {\n      alert('It started in VR mode because the camera or sensor could not be used.');\n      var geometry = new THREE.SphereGeometry(5, 60, 40);\n      geometry.scale(-1, 1, 1);\n      var material = new THREE.MeshBasicMaterial({\n        map: THREE.ImageUtils.loadTexture(_skybox_png__WEBPACK_IMPORTED_MODULE_1___default.a)\n      });\n      var sphere = new THREE.Mesh(geometry, material);\n      scene.add(sphere);\n    }\n  },\n  error: function error() {\n    alert('It started in VR mode because the camera or sensor could not be used.');\n  }\n});\ncontrols.connect();\nvar amlight = new THREE.AmbientLight(0xFFFFFF, 1.0);\nscene.add(amlight);\nvar light = new THREE.DirectionalLight(0x999999);\nlight.position.set(0, 100, 0);\nlight.castShadow = true;\nscene.add(light);\nvar geometry = new THREE.BoxGeometry(1, 1, 1);\nvar material = new THREE.MeshStandardMaterial({\n  color: 0x00ff00\n});\nvar cube = new THREE.Mesh(geometry, material);\ncube.position.z = -2;\nscene.add(cube);\n\nvar animate = function animate() {\n  renderer.autoClear = false;\n  renderer.clear();\n  renderer.render(scene, camera);\n  controls.update();\n  requestAnimationFrame(animate);\n};\n\nanimate();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/skybox.png":
/*!************************!*\
  !*** ./src/skybox.png ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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bfBXjN2sb17abOIyTvBwNj10ZFdc5o0ajB25ibkvyw8tMliK3Ev9H7htcyBXFub6DrwabBc+NXNlncktntz3TE2nPusica+a4fzV5DDHGFDiMecN9DviLzy0nZXdBV+3uBPcazUvfFPu6cYjhoePLgl2ydNFgzuMT/NgWLPI9k7z210SOWigxemkDQguTWeirGPeq1ljsmNYcqc2bsirJqzotXZeTn25/271SscRD/PmVqsaDLH7Rf91bkUxZNpldzC6jVvCRZp3HLbUueDIM5gPujluck0Mo82amOP4xFmz0bJIxsM6wioP/V5/Du0/tE/Gc3/92/8t3wB2ViQ7OAUr7CGK9aJ4bXQ20nQL+pckQhKt4whMIxxhfDvzrEo+2UzJ79bezoaBHka9Q72KEMXii3BoPV27XXtUbWivrlzXNpN4rmYohjSJcEI8kHTx9UNyUo5Yc8zpMN61ucNmF5vOv13/O5ze2uzwPPlfMxv1981fqmQdrrv7tP/OhxMHMLZcpuTa7+J68oOLAfqB6qF+62L+5nct88Y9Lm7cM6+crDHdxdbES8pfk3/cvRMfdjzhOKbzT9f2V/5U+yquplh1/HjDxBdufuVf9uGFizu9/eIPF/P0241X1e6Tlmp7FR8uXjtOuvm7K3vSvZuuTxh9yce6GCRvMj5e+KG7x+H/C3e/YshpY8fRylu3/rnY72L1lpd0WtDl5k57J16M+zV26NsXLN/qcO160bmun4qJW0yynx1u9R61wYRDx3s3/euuO4549U+nH1rmze8ujhxvO03XNnS8/JJXuTyY8cU23cqbYl4xccvlbvyh9pvygZcc4iUeOy4hN7s4cH699W/iQPVPFxs3XrnZTPPnLz6bcqeJW164/0succvXOg5y8eww1429Ok2feGziza49juPcvWqzKa67WH3BXYdr5cOJu29cMeF20qFX27sc/qYZE16Imw5vL5z+pQ5qQsc/6qtbXjXlaa94n/TzJfZvWjdp14Rfl3tMWFL7TtrwlYfVDy4HUC6a4s7de7u/08xO3yaNnfi6i+VXruni0uHkprm/a1PHVw7nv4ORLia7/inP3mK8w73j625uaNJzxz0vHKB8EuV0etth/FV3bs/fxoMdL7H/t1yEceLmDW75t+PnTgdusTD5aNKhV95QHbxp240DX/p5y5UcvtV/U7w4m/5Ou19z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\"\n\n//# sourceURL=webpack:///./src/skybox.png?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--5-1!./style.css */ \"./node_modules/css-loader/dist/cjs.js?!./src/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/style.css?");

/***/ })

/******/ });